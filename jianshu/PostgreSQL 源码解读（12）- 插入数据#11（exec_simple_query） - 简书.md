本文简单介绍了PG插入数据部分的源码，主要内容包括exec_simple_query函数的实现逻辑，该函数位于src/backend/tcop/postgres.c文件中。

### 一、源码解读

exec_simple_query函数，顾名思义，执行简单“查询”（包括INSERT/UPDATE/DELETE等语句）

    
    
    /*
     * exec_simple_query
     *
     * Execute a "simple Query" protocol message.
     */
    /*
    输入：
        query_string-SQL语句
    输出：
        无
    */
    static void
    exec_simple_query(const char *query_string)
    {
        CommandDest dest = whereToSendOutput;//输出到哪里的定义
        MemoryContext oldcontext;//存储原内存上下文
        List       *parsetree_list;//分析树列表
        ListCell   *parsetree_item;//分析树中的ITEM
        bool        save_log_statement_stats = log_statement_stats;//是否保存统计信息，false
        bool        was_logged = false;//Log？
        bool        use_implicit_block;//是否使用隐式事务块
        char        msec_str[32];
    
        /*
         * Report query to various monitoring facilities.
         */
        debug_query_string = query_string;
    
        pgstat_report_activity(STATE_RUNNING, query_string);//统计信息
    
        TRACE_POSTGRESQL_QUERY_START(query_string);
    
        /*
         * We use save_log_statement_stats so ShowUsage doesn't report incorrect
         * results because ResetUsage wasn't called.
         */
        if (save_log_statement_stats)
            ResetUsage();
    
        /*
         * Start up a transaction command.  All queries generated by the
         * query_string will be in this same command block, *unless* we find a
         * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
         * one of those, else bad things will happen in xact.c. (Note that this
         * will normally change current memory context.)
         */
        start_xact_command();//启动事务
    
        /*
         * Zap any pre-existing unnamed statement.  (While not strictly necessary,
         * it seems best to define simple-Query mode as if it used the unnamed
         * statement and portal; this ensures we recover any storage used by prior
         * unnamed operations.)
         */
        drop_unnamed_stmt();//清除匿名语句
    
        /*
         * Switch to appropriate context for constructing parsetrees.
         */
        oldcontext = MemoryContextSwitchTo(MessageContext);//切换内存上下文
    
        /*
         * Do basic parsing of the query or queries (this should be safe even if
         * we are in aborted transaction state!)
         */
        parsetree_list = pg_parse_query(query_string);//解析输入的查询语句，获得分析树List（元素是RawStmt nodes）
    
        /* Log immediately if dictated by log_statement */
        if (check_log_statement(parsetree_list))//日志记录
        {
            ereport(LOG,
                    (errmsg("statement: %s", query_string),
                     errhidestmt(true),
                     errdetail_execute(parsetree_list)));
            was_logged = true;
        }
    
        /*
         * Switch back to transaction context to enter the loop.
         */
        MemoryContextSwitchTo(oldcontext);//切换回原内存上下文
    
        /*
         * For historical reasons, if multiple SQL statements are given in a
         * single "simple Query" message, we execute them as a single transaction,
         * unless explicit transaction control commands are included to make
         * portions of the list be separate transactions.  To represent this
         * behavior properly in the transaction machinery, we use an "implicit"
         * transaction block.
         */
        use_implicit_block = (list_length(parsetree_list) > 1);//如果分析树条目>1，使用隐式事务块（多条SQL语句在同一个事务中）
    
        /*
         * Run through the raw parsetree(s) and process each one.
         */
        foreach(parsetree_item, parsetree_list)//对分析树中的每一个条目进行处理
        {
            RawStmt    *parsetree = lfirst_node(RawStmt, parsetree_item);//分析树List中的元素为RawStmt指针类型
            bool        snapshot_set = false;//是否设置快照？
            const char *commandTag;//命令标识
            char        completionTag[COMPLETION_TAG_BUFSIZE];//完成标记，如INSERT 0 1之类的字符串
            List       *querytree_list,//查询树List
                       *plantree_list;//执行计划List
            Portal      portal;//“门户”变量
            DestReceiver *receiver;//目标接收端
            int16       format;//
    
            /*
             * Get the command name for use in status display (it also becomes the
             * default completion tag, down inside PortalRun).  Set ps_status and
             * do any special start-of-SQL-command processing needed by the
             * destination.
             */
            commandTag = CreateCommandTag(parsetree->stmt);//创建命令标记，插入数据则为INSERT
    
            set_ps_display(commandTag, false);
    
            BeginCommand(commandTag, dest);//do Nothing!
    
            /*
             * If we are in an aborted transaction, reject all commands except
             * COMMIT/ABORT.  It is important that this test occur before we try
             * to do parse analysis, rewrite, or planning, since all those phases
             * try to do database accesses, which may fail in abort state. (It
             * might be safe to allow some additional utility commands in this
             * state, but not many...)
             */
            if (IsAbortedTransactionBlockState() &&
                !IsTransactionExitStmt(parsetree->stmt))
                ereport(ERROR,
                        (errcode(ERRCODE_IN_FAILED_SQL_TRANSACTION),
                         errmsg("current transaction is aborted, "
                                "commands ignored until end of transaction block"),
                         errdetail_abort()));
    
            /* Make sure we are in a transaction command */
            start_xact_command();//确认在事务中
    
            /*
             * If using an implicit transaction block, and we're not already in a
             * transaction block, start an implicit block to force this statement
             * to be grouped together with any following ones.  (We must do this
             * each time through the loop; otherwise, a COMMIT/ROLLBACK in the
             * list would cause later statements to not be grouped.)
             */
            if (use_implicit_block)
                BeginImplicitTransactionBlock();//隐式事务，进入事务块
    
            /* If we got a cancel signal in parsing or prior command, quit */
            CHECK_FOR_INTERRUPTS();
    
            /*
             * Set up a snapshot if parse analysis/planning will need one.
             */
            if (analyze_requires_snapshot(parsetree))//是否需要快照进行分析？增删改查均需要
            {
                PushActiveSnapshot(GetTransactionSnapshot());//
                snapshot_set = true;
            }
    
            /*
             * OK to analyze, rewrite, and plan this query.
             *
             * Switch to appropriate context for constructing querytrees (again,
             * these must outlive the execution context).
             */
            oldcontext = MemoryContextSwitchTo(MessageContext);//切换内存上下文
    
            querytree_list = pg_analyze_and_rewrite(parsetree, query_string,
                                                    NULL, 0, NULL);//根据分析树获得查询树，返回List（元素为Query）
    
            plantree_list = pg_plan_queries(querytree_list,
                                            CURSOR_OPT_PARALLEL_OK, NULL);//根据查询树获取计划树，返回List（元素为PlannedStmt）
    
            /* Done with the snapshot used for parsing/planning */
            if (snapshot_set)
                PopActiveSnapshot();//
    
            /* If we got a cancel signal in analysis or planning, quit */
            CHECK_FOR_INTERRUPTS();
    
            /*
             * Create unnamed portal to run the query or queries in. If there
             * already is one, silently drop it.
             */
            portal = CreatePortal("", true, true);//创建匿名Portal变量
            /* Don't display the portal in pg_cursors */
            portal->visible = false;
    
            /*
             * We don't have to copy anything into the portal, because everything
             * we are passing here is in MessageContext, which will outlive the
             * portal anyway.
             */
            PortalDefineQuery(portal,
                              NULL,
                              query_string,
                              commandTag,
                              plantree_list,
                              NULL);//给Portal变量赋值
    
            /*
             * Start the portal.  No parameters here.
             */
            PortalStart(portal, NULL, 0, InvalidSnapshot);//为PortalRun作准备
    
            /*
             * Select the appropriate output format: text unless we are doing a
             * FETCH from a binary cursor.  (Pretty grotty to have to do this here
             * --- but it avoids grottiness in other places.  Ah, the joys of
             * backward compatibility...)
             */
            format = 0;             /* TEXT is default */
            if (IsA(parsetree->stmt, FetchStmt))
            {
                FetchStmt  *stmt = (FetchStmt *) parsetree->stmt;
    
                if (!stmt->ismove)
                {
                    Portal      fportal = GetPortalByName(stmt->portalname);
    
                    if (PortalIsValid(fportal) &&
                        (fportal->cursorOptions & CURSOR_OPT_BINARY))
                        format = 1; /* BINARY */
                }
            }
            PortalSetResultFormat(portal, 1, &format);//设置结果返回的格式，默认为TEXT
    
            /*
             * Now we can create the destination receiver object.
             */
            receiver = CreateDestReceiver(dest);//创建目标接收器(如使用psql则为：printtup DestReceiver)
            if (dest == DestRemote)
                SetRemoteDestReceiverParams(receiver, portal);
    
            /*
             * Switch back to transaction context for execution.
             */
            MemoryContextSwitchTo(oldcontext);//切换回原内存上下文
    
            /*
             * Run the portal to completion, and then drop it (and the receiver).
             */
            (void) PortalRun(portal,
                             FETCH_ALL,
                             true,  /* always top level */
                             true,
                             receiver,
                             receiver,
                             completionTag);//执行
    
            receiver->rDestroy(receiver);//执行完毕，销毁接收器
    
            PortalDrop(portal, false);//清除Portal中的资源&Portal
    
            if (lnext(parsetree_item) == NULL)//所有语句已执行完毕
            {
                /*
                 * If this is the last parsetree of the query string, close down
                 * transaction statement before reporting command-complete.  This
                 * is so that any end-of-transaction errors are reported before
                 * the command-complete message is issued, to avoid confusing
                 * clients who will expect either a command-complete message or an
                 * error, not one and then the other.  Also, if we're using an
                 * implicit transaction block, we must close that out first.
                 */
                if (use_implicit_block)
                    EndImplicitTransactionBlock();//结束事务
                finish_xact_command();//结束事务
            }
            else if (IsA(parsetree->stmt, TransactionStmt))//事务语句？BEGIN/COMMIT/ABORT...
            {
                /*
                 * If this was a transaction control statement, commit it. We will
                 * start a new xact command for the next command.
                 */
                finish_xact_command();
            }
            else
            {
                /*
                 * We need a CommandCounterIncrement after every query, except
                 * those that start or end a transaction block.
                 */
                CommandCounterIncrement();//命令+1（对应Tuple中的cid）
            }
    
            /*
             * Tell client that we're done with this query.  Note we emit exactly
             * one EndCommand report for each raw parsetree, thus one for each SQL
             * command the client sent, regardless of rewriting. (But a command
             * aborted by error will not send an EndCommand report at all.)
             */
            EndCommand(completionTag, dest);//命令Done
        }                           /* end loop over parsetrees */
        
        //所有语句结束
        /*
         * Close down transaction statement, if one is open.  (This will only do
         * something if the parsetree list was empty; otherwise the last loop
         * iteration already did it.)
         */
        finish_xact_command();
    
        /*
         * If there were no parsetrees, return EmptyQueryResponse message.
         */
        if (!parsetree_list)
            NullCommand(dest);
    
        /*
         * Emit duration logging if appropriate.
         */
        switch (check_log_duration(msec_str, was_logged))
        {
            case 1:
                ereport(LOG,
                        (errmsg("duration: %s ms", msec_str),
                         errhidestmt(true)));
                break;
            case 2:
                ereport(LOG,
                        (errmsg("duration: %s ms  statement: %s",
                                msec_str, query_string),
                         errhidestmt(true),
                         errdetail_execute(parsetree_list)));
                break;
        }
    
        if (save_log_statement_stats)
            ShowUsage("QUERY STATISTICS");
    
        TRACE_POSTGRESQL_QUERY_DONE(query_string);
    
        debug_query_string = NULL;
    }
    
    

### 二、基础信息

exec_simple_query函数使用的数据结构、宏定义以及依赖的函数等。  
**数据结构/宏定义**  
*1、whereToSendOutput *
    
    
     /* Note: whereToSendOutput is initialized for the bootstrap/standalone case */
     CommandDest whereToSendOutput = DestDebug;
    
     /* ----------------      *      CommandDest is a simplistic means of identifying the desired
      *      destination.  Someday this will probably need to be improved.
      *
      * Note: only the values DestNone, DestDebug, DestRemote are legal for the
      * global variable whereToSendOutput.   The other values may be used
      * as the destination for individual commands.
      * ----------------      */
     typedef enum
     {
         DestNone,                   /* results are discarded */
         DestDebug,                  /* results go to debugging output */
         DestRemote,                 /* results sent to frontend process */
         DestRemoteExecute,          /* sent to frontend, in Execute command */
         DestRemoteSimple,           /* sent to frontend, w/no catalog access */
         DestSPI,                    /* results sent to SPI manager */
         DestTuplestore,             /* results sent to Tuplestore */
         DestIntoRel,                /* results sent to relation (SELECT INTO) */
         DestCopyOut,                /* results sent to COPY TO code */
         DestSQLFunction,            /* results sent to SQL-language func mgr */
         DestTransientRel,           /* results sent to transient relation */
         DestTupleQueue              /* results sent to tuple queue */
     } CommandDest;
    

_2、RawStmt_

    
    
     
     /*
      *      RawStmt --- container for any one statement's raw parse tree
      *
      * Parse analysis converts a raw parse tree headed by a RawStmt node into
      * an analyzed statement headed by a Query node.  For optimizable statements,
      * the conversion is complex.  For utility statements, the parser usually just
      * transfers the raw parse tree (sans RawStmt) into the utilityStmt field of
      * the Query node, and all the useful work happens at execution time.
      *
      * stmt_location/stmt_len identify the portion of the source text string
      * containing this raw statement (useful for multi-statement strings).
      */
     typedef struct RawStmt
     {
         NodeTag     type;
         Node       *stmt;           /* raw parse tree */
         int         stmt_location;  /* start location, or -1 if unknown */
         int         stmt_len;       /* length in bytes; 0 means "rest of string" */
     } RawStmt;
    

_3、Query_

    
    
    //在解析查询语句时再深入解析
    /*****************************************************************************
      *  Query Tree
      *****************************************************************************/
     
     /*
      * Query -      *    Parse analysis turns all statements into a Query tree
      *    for further processing by the rewriter and planner.
      *
      *    Utility statements (i.e. non-optimizable statements) have the
      *    utilityStmt field set, and the rest of the Query is mostly dummy.
      *
      *    Planning converts a Query tree into a Plan tree headed by a PlannedStmt
      *    node --- the Query structure is not used by the executor.
      */
     typedef struct Query
     {
         NodeTag     type;
     
         CmdType     commandType;    /* select|insert|update|delete|utility */
     
         QuerySource querySource;    /* where did I come from? */
     
         uint64      queryId;        /* query identifier (can be set by plugins) */
     
         bool        canSetTag;      /* do I set the command result tag? */
     
         Node       *utilityStmt;    /* non-null if commandType == CMD_UTILITY */
     
         int         resultRelation; /* rtable index of target relation for
                                      * INSERT/UPDATE/DELETE; 0 for SELECT */
     
         bool        hasAggs;        /* has aggregates in tlist or havingQual */
         bool        hasWindowFuncs; /* has window functions in tlist */
         bool        hasTargetSRFs;  /* has set-returning functions in tlist */
         bool        hasSubLinks;    /* has subquery SubLink */
         bool        hasDistinctOn;  /* distinctClause is from DISTINCT ON */
         bool        hasRecursive;   /* WITH RECURSIVE was specified */
         bool        hasModifyingCTE;    /* has INSERT/UPDATE/DELETE in WITH */
         bool        hasForUpdate;   /* FOR [KEY] UPDATE/SHARE was specified */
         bool        hasRowSecurity; /* rewriter has applied some RLS policy */
     
         List       *cteList;        /* WITH list (of CommonTableExpr's) */
     
         List       *rtable;         /* list of range table entries */
         FromExpr   *jointree;       /* table join tree (FROM and WHERE clauses) */
     
         List       *targetList;     /* target list (of TargetEntry) */
     
         OverridingKind override;    /* OVERRIDING clause */
     
         OnConflictExpr *onConflict; /* ON CONFLICT DO [NOTHING | UPDATE] */
     
         List       *returningList;  /* return-values list (of TargetEntry) */
     
         List       *groupClause;    /* a list of SortGroupClause's */
     
         List       *groupingSets;   /* a list of GroupingSet's if present */
     
         Node       *havingQual;     /* qualifications applied to groups */
     
         List       *windowClause;   /* a list of WindowClause's */
     
         List       *distinctClause; /* a list of SortGroupClause's */
     
         List       *sortClause;     /* a list of SortGroupClause's */
     
         Node       *limitOffset;    /* # of result tuples to skip (int8 expr) */
         Node       *limitCount;     /* # of result tuples to return (int8 expr) */
     
         List       *rowMarks;       /* a list of RowMarkClause's */
     
         Node       *setOperations;  /* set-operation tree if this is top level of
                                      * a UNION/INTERSECT/EXCEPT query */
     
         List       *constraintDeps; /* a list of pg_constraint OIDs that the query
                                      * depends on to be semantically valid */
     
         List       *withCheckOptions;   /* a list of WithCheckOption's, which are
                                          * only added during rewrite and therefore
                                          * are not written out as part of Query. */
     
         /*
          * The following two fields identify the portion of the source text string
          * containing this query.  They are typically only populated in top-level
          * Queries, not in sub-queries.  When not set, they might both be zero, or
          * both be -1 meaning "unknown".
          */
         int         stmt_location;  /* start location, or -1 if unknown */
         int         stmt_len;       /* length in bytes; 0 means "rest of string" */
     } Query;
     
    

_4、ParseState_

    
    
     /*
      * Function signatures for parser hooks
      */
     typedef struct ParseState ParseState;
     
     typedef Node *(*PreParseColumnRefHook) (ParseState *pstate, ColumnRef *cref);
     typedef Node *(*PostParseColumnRefHook) (ParseState *pstate, ColumnRef *cref, Node *var);
     typedef Node *(*ParseParamRefHook) (ParseState *pstate, ParamRef *pref);
     typedef Node *(*CoerceParamHook) (ParseState *pstate, Param *param,
                                       Oid targetTypeId, int32 targetTypeMod,
                                       int location);
     
     
     /*
      * State information used during parse analysis
      *
      * parentParseState: NULL in a top-level ParseState.  When parsing a subquery,
      * links to current parse state of outer query.
      *
      * p_sourcetext: source string that generated the raw parsetree being
      * analyzed, or NULL if not available.  (The string is used only to
      * generate cursor positions in error messages: we need it to convert
      * byte-wise locations in parse structures to character-wise cursor
      * positions.)
      *
      * p_rtable: list of RTEs that will become the rangetable of the query.
      * Note that neither relname nor refname of these entries are necessarily
      * unique; searching the rtable by name is a bad idea.
      *
      * p_joinexprs: list of JoinExpr nodes associated with p_rtable entries.
      * This is one-for-one with p_rtable, but contains NULLs for non-join
      * RTEs, and may be shorter than p_rtable if the last RTE(s) aren't joins.
      *
      * p_joinlist: list of join items (RangeTblRef and JoinExpr nodes) that
      * will become the fromlist of the query's top-level FromExpr node.
      *
      * p_namespace: list of ParseNamespaceItems that represents the current
      * namespace for table and column lookup.  (The RTEs listed here may be just
      * a subset of the whole rtable.  See ParseNamespaceItem comments below.)
      *
      * p_lateral_active: true if we are currently parsing a LATERAL subexpression
      * of this parse level.  This makes p_lateral_only namespace items visible,
      * whereas they are not visible when p_lateral_active is FALSE.
      *
      * p_ctenamespace: list of CommonTableExprs (WITH items) that are visible
      * at the moment.  This is entirely different from p_namespace because a CTE
      * is not an RTE, rather "visibility" means you could make an RTE from it.
      *
      * p_future_ctes: list of CommonTableExprs (WITH items) that are not yet
      * visible due to scope rules.  This is used to help improve error messages.
      *
      * p_parent_cte: CommonTableExpr that immediately contains the current query,
      * if any.
      *
      * p_target_relation: target relation, if query is INSERT, UPDATE, or DELETE.
      *
      * p_target_rangetblentry: target relation's entry in the rtable list.
      *
      * p_is_insert: true to process assignment expressions like INSERT, false
      * to process them like UPDATE.  (Note this can change intra-statement, for
      * cases like INSERT ON CONFLICT UPDATE.)
      *
      * p_windowdefs: list of WindowDefs representing WINDOW and OVER clauses.
      * We collect these while transforming expressions and then transform them
      * afterwards (so that any resjunk tlist items needed for the sort/group
      * clauses end up at the end of the query tlist).  A WindowDef's location in
      * this list, counting from 1, is the winref number to use to reference it.
      *
      * p_expr_kind: kind of expression we're currently parsing, as per enum above;
      * EXPR_KIND_NONE when not in an expression.
      *
      * p_next_resno: next TargetEntry.resno to assign, starting from 1.
      *
      * p_multiassign_exprs: partially-processed MultiAssignRef source expressions.
      *
      * p_locking_clause: query's FOR UPDATE/FOR SHARE clause, if any.
      *
      * p_locked_from_parent: true if parent query level applies FOR UPDATE/SHARE
      * to this subquery as a whole.
      *
      * p_resolve_unknowns: resolve unknown-type SELECT output columns as type TEXT
      * (this is true by default).
      *
      * p_hasAggs, p_hasWindowFuncs, etc: true if we've found any of the indicated
      * constructs in the query.
      *
      * p_last_srf: the set-returning FuncExpr or OpExpr most recently found in
      * the query, or NULL if none.
      *
      * p_pre_columnref_hook, etc: optional parser hook functions for modifying the
      * interpretation of ColumnRefs and ParamRefs.
      *
      * p_ref_hook_state: passthrough state for the parser hook functions.
      */
     struct ParseState
     {
         struct ParseState *parentParseState;    /* stack link */
         const char *p_sourcetext;   /* source text, or NULL if not available */
         List       *p_rtable;       /* range table so far */
         List       *p_joinexprs;    /* JoinExprs for RTE_JOIN p_rtable entries */
         List       *p_joinlist;     /* join items so far (will become FromExpr
                                      * node's fromlist) */
         List       *p_namespace;    /* currently-referenceable RTEs (List of
                                      * ParseNamespaceItem) */
         bool        p_lateral_active;   /* p_lateral_only items visible? */
         List       *p_ctenamespace; /* current namespace for common table exprs */
         List       *p_future_ctes;  /* common table exprs not yet in namespace */
         CommonTableExpr *p_parent_cte;  /* this query's containing CTE */
         Relation    p_target_relation;  /* INSERT/UPDATE/DELETE target rel */
         RangeTblEntry *p_target_rangetblentry;  /* target rel's RTE */
         bool        p_is_insert;    /* process assignment like INSERT not UPDATE */
         List       *p_windowdefs;   /* raw representations of window clauses */
         ParseExprKind p_expr_kind;  /* what kind of expression we're parsing */
         int         p_next_resno;   /* next targetlist resno to assign */
         List       *p_multiassign_exprs;    /* junk tlist entries for multiassign */
         List       *p_locking_clause;   /* raw FOR UPDATE/FOR SHARE info */
         bool        p_locked_from_parent;   /* parent has marked this subquery
                                              * with FOR UPDATE/FOR SHARE */
         bool        p_resolve_unknowns; /* resolve unknown-type SELECT outputs as
                                          * type text */
     
         QueryEnvironment *p_queryEnv;   /* curr env, incl refs to enclosing env */
     
         /* Flags telling about things found in the query: */
         bool        p_hasAggs;
         bool        p_hasWindowFuncs;
         bool        p_hasTargetSRFs;
         bool        p_hasSubLinks;
         bool        p_hasModifyingCTE;
     
         Node       *p_last_srf;     /* most recent set-returning func/op found */
     
         /*
          * Optional hook functions for parser callbacks.  These are null unless
          * set up by the caller of make_parsestate.
          */
         PreParseColumnRefHook p_pre_columnref_hook;
         PostParseColumnRefHook p_post_columnref_hook;
         ParseParamRefHook p_paramref_hook;
         CoerceParamHook p_coerce_param_hook;
         void       *p_ref_hook_state;   /* common passthrough link for above */
     };
     
    

_5、RangeTblEntry_

    
    
     /*--------------------      * RangeTblEntry -      *    A range table is a List of RangeTblEntry nodes.
      *
      *    A range table entry may represent a plain relation, a sub-select in
      *    FROM, or the result of a JOIN clause.  (Only explicit JOIN syntax
      *    produces an RTE, not the implicit join resulting from multiple FROM
      *    items.  This is because we only need the RTE to deal with SQL features
      *    like outer joins and join-output-column aliasing.)  Other special
      *    RTE types also exist, as indicated by RTEKind.
      *
      *    Note that we consider RTE_RELATION to cover anything that has a pg_class
      *    entry.  relkind distinguishes the sub-cases.
      *
      *    alias is an Alias node representing the AS alias-clause attached to the
      *    FROM expression, or NULL if no clause.
      *
      *    eref is the table reference name and column reference names (either
      *    real or aliases).  Note that system columns (OID etc) are not included
      *    in the column list.
      *    eref->aliasname is required to be present, and should generally be used
      *    to identify the RTE for error messages etc.
      *
      *    In RELATION RTEs, the colnames in both alias and eref are indexed by
      *    physical attribute number; this means there must be colname entries for
      *    dropped columns.  When building an RTE we insert empty strings ("") for
      *    dropped columns.  Note however that a stored rule may have nonempty
      *    colnames for columns dropped since the rule was created (and for that
      *    matter the colnames might be out of date due to column renamings).
      *    The same comments apply to FUNCTION RTEs when a function's return type
      *    is a named composite type.
      *
      *    In JOIN RTEs, the colnames in both alias and eref are one-to-one with
      *    joinaliasvars entries.  A JOIN RTE will omit columns of its inputs when
      *    those columns are known to be dropped at parse time.  Again, however,
      *    a stored rule might contain entries for columns dropped since the rule
      *    was created.  (This is only possible for columns not actually referenced
      *    in the rule.)  When loading a stored rule, we replace the joinaliasvars
      *    items for any such columns with null pointers.  (We can't simply delete
      *    them from the joinaliasvars list, because that would affect the attnums
      *    of Vars referencing the rest of the list.)
      *
      *    inh is true for relation references that should be expanded to include
      *    inheritance children, if the rel has any.  This *must* be false for
      *    RTEs other than RTE_RELATION entries.
      *
      *    inFromCl marks those range variables that are listed in the FROM clause.
      *    It's false for RTEs that are added to a query behind the scenes, such
      *    as the NEW and OLD variables for a rule, or the subqueries of a UNION.
      *    This flag is not used anymore during parsing, since the parser now uses
      *    a separate "namespace" data structure to control visibility, but it is
      *    needed by ruleutils.c to determine whether RTEs should be shown in
      *    decompiled queries.
      *
      *    requiredPerms and checkAsUser specify run-time access permissions
      *    checks to be performed at query startup.  The user must have *all*
      *    of the permissions that are OR'd together in requiredPerms (zero
      *    indicates no permissions checking).  If checkAsUser is not zero,
      *    then do the permissions checks using the access rights of that user,
      *    not the current effective user ID.  (This allows rules to act as
      *    setuid gateways.)  Permissions checks only apply to RELATION RTEs.
      *
      *    For SELECT/INSERT/UPDATE permissions, if the user doesn't have
      *    table-wide permissions then it is sufficient to have the permissions
      *    on all columns identified in selectedCols (for SELECT) and/or
      *    insertedCols and/or updatedCols (INSERT with ON CONFLICT DO UPDATE may
      *    have all 3).  selectedCols, insertedCols and updatedCols are bitmapsets,
      *    which cannot have negative integer members, so we subtract
      *    FirstLowInvalidHeapAttributeNumber from column numbers before storing
      *    them in these fields.  A whole-row Var reference is represented by
      *    setting the bit for InvalidAttrNumber.
      *
      *    securityQuals is a list of security barrier quals (boolean expressions),
      *    to be tested in the listed order before returning a row from the
      *    relation.  It is always NIL in parser output.  Entries are added by the
      *    rewriter to implement security-barrier views and/or row-level security.
      *    Note that the planner turns each boolean expression into an implicitly
      *    AND'ed sublist, as is its usual habit with qualification expressions.
      *--------------------      */
     typedef enum RTEKind
     {
         RTE_RELATION,               /* ordinary relation reference */
         RTE_SUBQUERY,               /* subquery in FROM */
         RTE_JOIN,                   /* join */
         RTE_FUNCTION,               /* function in FROM */
         RTE_TABLEFUNC,              /* TableFunc(.., column list) */
         RTE_VALUES,                 /* VALUES (<exprlist>), (<exprlist>), ... */
         RTE_CTE,                    /* common table expr (WITH list element) */
         RTE_NAMEDTUPLESTORE         /* tuplestore, e.g. for AFTER triggers */
     } RTEKind;
     
     typedef struct RangeTblEntry
     {
         NodeTag     type;
     
         RTEKind     rtekind;        /* see above */
     
         /*
          * XXX the fields applicable to only some rte kinds should be merged into
          * a union.  I didn't do this yet because the diffs would impact a lot of
          * code that is being actively worked on.  FIXME someday.
          */
     
         /*
          * Fields valid for a plain relation RTE (else zero):
          *
          * As a special case, RTE_NAMEDTUPLESTORE can also set relid to indicate
          * that the tuple format of the tuplestore is the same as the referenced
          * relation.  This allows plans referencing AFTER trigger transition
          * tables to be invalidated if the underlying table is altered.
          */
         Oid         relid;          /* OID of the relation */
         char        relkind;        /* relation kind (see pg_class.relkind) */
         struct TableSampleClause *tablesample;  /* sampling info, or NULL */
     
         /*
          * Fields valid for a subquery RTE (else NULL):
          */
         Query      *subquery;       /* the sub-query */
         bool        security_barrier;   /* is from security_barrier view? */
     
         /*
          * Fields valid for a join RTE (else NULL/zero):
          *
          * joinaliasvars is a list of (usually) Vars corresponding to the columns
          * of the join result.  An alias Var referencing column K of the join
          * result can be replaced by the K'th element of joinaliasvars --- but to
          * simplify the task of reverse-listing aliases correctly, we do not do
          * that until planning time.  In detail: an element of joinaliasvars can
          * be a Var of one of the join's input relations, or such a Var with an
          * implicit coercion to the join's output column type, or a COALESCE
          * expression containing the two input column Vars (possibly coerced).
          * Within a Query loaded from a stored rule, it is also possible for
          * joinaliasvars items to be null pointers, which are placeholders for
          * (necessarily unreferenced) columns dropped since the rule was made.
          * Also, once planning begins, joinaliasvars items can be almost anything,
          * as a result of subquery-flattening substitutions.
          */
         JoinType    jointype;       /* type of join */
         List       *joinaliasvars;  /* list of alias-var expansions */
     
         /*
          * Fields valid for a function RTE (else NIL/zero):
          *
          * When funcordinality is true, the eref->colnames list includes an alias
          * for the ordinality column.  The ordinality column is otherwise
          * implicit, and must be accounted for "by hand" in places such as
          * expandRTE().
          */
         List       *functions;      /* list of RangeTblFunction nodes */
         bool        funcordinality; /* is this called WITH ORDINALITY? */
     
         /*
          * Fields valid for a TableFunc RTE (else NULL):
          */
         TableFunc  *tablefunc;
     
         /*
          * Fields valid for a values RTE (else NIL):
          */
         List       *values_lists;   /* list of expression lists */
     
         /*
          * Fields valid for a CTE RTE (else NULL/zero):
          */
         char       *ctename;        /* name of the WITH list item */
         Index       ctelevelsup;    /* number of query levels up */
         bool        self_reference; /* is this a recursive self-reference? */
     
         /*
          * Fields valid for table functions, values, CTE and ENR RTEs (else NIL):
          *
          * We need these for CTE RTEs so that the types of self-referential
          * columns are well-defined.  For VALUES RTEs, storing these explicitly
          * saves having to re-determine the info by scanning the values_lists. For
          * ENRs, we store the types explicitly here (we could get the information
          * from the catalogs if 'relid' was supplied, but we'd still need these
          * for TupleDesc-based ENRs, so we might as well always store the type
          * info here).
          *
          * For ENRs only, we have to consider the possibility of dropped columns.
          * A dropped column is included in these lists, but it will have zeroes in
          * all three lists (as well as an empty-string entry in eref).  Testing
          * for zero coltype is the standard way to detect a dropped column.
          */
         List       *coltypes;       /* OID list of column type OIDs */
         List       *coltypmods;     /* integer list of column typmods */
         List       *colcollations;  /* OID list of column collation OIDs */
     
         /*
          * Fields valid for ENR RTEs (else NULL/zero):
          */
         char       *enrname;        /* name of ephemeral named relation */
         double      enrtuples;      /* estimated or actual from caller */
     
         /*
          * Fields valid in all RTEs:
          */
         Alias      *alias;          /* user-written alias clause, if any */
         Alias      *eref;           /* expanded reference names */
         bool        lateral;        /* subquery, function, or values is LATERAL? */
         bool        inh;            /* inheritance requested? */
         bool        inFromCl;       /* present in FROM clause? */
         AclMode     requiredPerms;  /* bitmask of required access permissions */
         Oid         checkAsUser;    /* if valid, check access as this role */
         Bitmapset  *selectedCols;   /* columns needing SELECT permission */
         Bitmapset  *insertedCols;   /* columns needing INSERT permission */
         Bitmapset  *updatedCols;    /* columns needing UPDATE permission */
         List       *securityQuals;  /* security barrier quals to apply, if any */
     } RangeTblEntry;
     
    

_6、TargetEntry_

    
    
     /*--------------------      * TargetEntry -      *     a target entry (used in query target lists)
      *
      * Strictly speaking, a TargetEntry isn't an expression node (since it can't
      * be evaluated by ExecEvalExpr).  But we treat it as one anyway, since in
      * very many places it's convenient to process a whole query targetlist as a
      * single expression tree.
      *
      * In a SELECT's targetlist, resno should always be equal to the item's
      * ordinal position (counting from 1).  However, in an INSERT or UPDATE
      * targetlist, resno represents the attribute number of the destination
      * column for the item; so there may be missing or out-of-order resnos.
      * It is even legal to have duplicated resnos; consider
      *      UPDATE table SET arraycol[1] = ..., arraycol[2] = ..., ...
      * The two meanings come together in the executor, because the planner
      * transforms INSERT/UPDATE tlists into a normalized form with exactly
      * one entry for each column of the destination table.  Before that's
      * happened, however, it is risky to assume that resno == position.
      * Generally get_tle_by_resno() should be used rather than list_nth()
      * to fetch tlist entries by resno, and only in SELECT should you assume
      * that resno is a unique identifier.
      *
      * resname is required to represent the correct column name in non-resjunk
      * entries of top-level SELECT targetlists, since it will be used as the
      * column title sent to the frontend.  In most other contexts it is only
      * a debugging aid, and may be wrong or even NULL.  (In particular, it may
      * be wrong in a tlist from a stored rule, if the referenced column has been
      * renamed by ALTER TABLE since the rule was made.  Also, the planner tends
      * to store NULL rather than look up a valid name for tlist entries in
      * non-toplevel plan nodes.)  In resjunk entries, resname should be either
      * a specific system-generated name (such as "ctid") or NULL; anything else
      * risks confusing ExecGetJunkAttribute!
      *
      * ressortgroupref is used in the representation of ORDER BY, GROUP BY, and
      * DISTINCT items.  Targetlist entries with ressortgroupref=0 are not
      * sort/group items.  If ressortgroupref>0, then this item is an ORDER BY,
      * GROUP BY, and/or DISTINCT target value.  No two entries in a targetlist
      * may have the same nonzero ressortgroupref --- but there is no particular
      * meaning to the nonzero values, except as tags.  (For example, one must
      * not assume that lower ressortgroupref means a more significant sort key.)
      * The order of the associated SortGroupClause lists determine the semantics.
      *
      * resorigtbl/resorigcol identify the source of the column, if it is a
      * simple reference to a column of a base table (or view).  If it is not
      * a simple reference, these fields are zeroes.
      *
      * If resjunk is true then the column is a working column (such as a sort key)
      * that should be removed from the final output of the query.  Resjunk columns
      * must have resnos that cannot duplicate any regular column's resno.  Also
      * note that there are places that assume resjunk columns come after non-junk
      * columns.
      *--------------------      */
     typedef struct TargetEntry
     {
         Expr        xpr;
         Expr       *expr;           /* expression to evaluate */
         AttrNumber  resno;          /* attribute number (see notes above) */
         char       *resname;        /* name of the column (could be NULL) */
         Index       ressortgroupref;    /* nonzero if referenced by a sort/group
                                          * clause */
         Oid         resorigtbl;     /* OID of column's source table */
         AttrNumber  resorigcol;     /* column's number in source table */
         bool        resjunk;        /* set to true to eliminate the attribute from
                                      * final target list */
     } TargetEntry;
     
     
    

_7、全局变量定义_

    
    
     bool        log_parser_stats = false;
     bool        log_planner_stats = false;
     bool        log_executor_stats = false;
     bool        log_statement_stats = false;    /* this is sort of all three above
                                                  * together */
    

**依赖的函数**  
_1、start_xact_command_

    
    
     /*
      * Convenience routines for starting/committing a single command.
      */
     static void
     start_xact_command(void)
     {
         if (!xact_started)
         {
             StartTransactionCommand();//开启事务
     
             xact_started = true;
         }
     
         /*
          * Start statement timeout if necessary.  Note that this'll intentionally
          * not reset the clock on an already started timeout, to avoid the timing
          * overhead when start_xact_command() is invoked repeatedly, without an
          * interceding finish_xact_command() (e.g. parse/bind/execute).  If that's
          * not desired, the timeout has to be disabled explicitly.
          */
         enable_statement_timeout();
     }
    
     /*
      *  StartTransactionCommand
      */
     void
     StartTransactionCommand(void)
     {
         TransactionState s = CurrentTransactionState;
     
         switch (s->blockState)
         {
                 /*
                  * if we aren't in a transaction block, we just do our usual start
                  * transaction.
                  */
             case TBLOCK_DEFAULT:
                 StartTransaction();
                 s->blockState = TBLOCK_STARTED;
                 break;
     
                 /*
                  * We are somewhere in a transaction block or subtransaction and
                  * about to start a new command.  For now we do nothing, but
                  * someday we may do command-local resource initialization. (Note
                  * that any needed CommandCounterIncrement was done by the
                  * previous CommitTransactionCommand.)
                  */
             case TBLOCK_INPROGRESS:
             case TBLOCK_IMPLICIT_INPROGRESS:
             case TBLOCK_SUBINPROGRESS:
                 break;
     
                 /*
                  * Here we are in a failed transaction block (one of the commands
                  * caused an abort) so we do nothing but remain in the abort
                  * state.  Eventually we will get a ROLLBACK command which will
                  * get us out of this state.  (It is up to other code to ensure
                  * that no commands other than ROLLBACK will be processed in these
                  * states.)
                  */
             case TBLOCK_ABORT:
             case TBLOCK_SUBABORT:
                 break;
     
                 /* These cases are invalid. */
             case TBLOCK_STARTED:
             case TBLOCK_BEGIN:
             case TBLOCK_PARALLEL_INPROGRESS:
             case TBLOCK_SUBBEGIN:
             case TBLOCK_END:
             case TBLOCK_SUBRELEASE:
             case TBLOCK_SUBCOMMIT:
             case TBLOCK_ABORT_END:
             case TBLOCK_SUBABORT_END:
             case TBLOCK_ABORT_PENDING:
             case TBLOCK_SUBABORT_PENDING:
             case TBLOCK_SUBRESTART:
             case TBLOCK_SUBABORT_RESTART:
             case TBLOCK_PREPARE:
                 elog(ERROR, "StartTransactionCommand: unexpected state %s",
                      BlockStateAsString(s->blockState));
                 break;
         }
     
         /*
          * We must switch to CurTransactionContext before returning. This is
          * already done if we called StartTransaction, otherwise not.
          */
         Assert(CurTransactionContext != NULL);
         MemoryContextSwitchTo(CurTransactionContext);//内存上下文切换至当前事务上下文
     }
     
    
    

_2、drop_unnamed_stmt_

    
    
     /* Release any existing unnamed prepared statement */
     static void
     drop_unnamed_stmt(void)
     {
         /* paranoia to avoid a dangling pointer in case of error */
         if (unnamed_stmt_psrc)
         {
             CachedPlanSource *psrc = unnamed_stmt_psrc;
     
             unnamed_stmt_psrc = NULL;
             DropCachedPlan(psrc);
         }
     }
    
     /*
      * If an unnamed prepared statement exists, it's stored here.
      * We keep it separate from the hashtable kept by commands/prepare.c
      * in order to reduce overhead for short-lived queries.
      */
     static CachedPlanSource *unnamed_stmt_psrc = NULL;
    

_3、pg_parse_query_

    
    
    //执行语句解析，返回RawStmt  nodes（List）
     /*
      * Do raw parsing (only).
      *
      * A list of parsetrees (RawStmt nodes) is returned, since there might be
      * multiple commands in the given string.
      *
      * NOTE: for interactive queries, it is important to keep this routine
      * separate from the analysis & rewrite stages.  Analysis and rewriting
      * cannot be done in an aborted transaction, since they require access to
      * database tables.  So, we rely on the raw parser to determine whether
      * we've seen a COMMIT or ABORT command; when we are in abort state, other
      * commands are not processed any further than the raw parse stage.
      */
     List *
     pg_parse_query(const char *query_string)
     {
         List       *raw_parsetree_list;
     
         TRACE_POSTGRESQL_QUERY_PARSE_START(query_string);
     
         if (log_parser_stats)
             ResetUsage();
     
         raw_parsetree_list = raw_parser(query_string);
     
         if (log_parser_stats)
             ShowUsage("PARSER STATISTICS");
     
     #ifdef COPY_PARSE_PLAN_TREES
         /* Optional debugging check: pass raw parsetrees through copyObject() */
         {
             List       *new_list = copyObject(raw_parsetree_list);
     
             /* This checks both copyObject() and the equal() routines... */
             if (!equal(new_list, raw_parsetree_list))
                 elog(WARNING, "copyObject() failed to produce an equal raw parse tree");
             else
                 raw_parsetree_list = new_list;
         }
     #endif
     
         TRACE_POSTGRESQL_QUERY_PARSE_DONE(query_string);
     
         return raw_parsetree_list;
     }
    

_4、raw_parser_

    
    
    //执行词法和语法分析，返回raw parse trees（List，其中的元素是RawStmt）
     /*
      * raw_parser
      *      Given a query in string form, do lexical and grammatical analysis.
      *
      * Returns a list of raw (un-analyzed) parse trees.  The immediate elements
      * of the list are always RawStmt nodes.
      */
     List *
     raw_parser(const char *str)
     {
         core_yyscan_t yyscanner;
         base_yy_extra_type yyextra;
         int         yyresult;
     
         /* initialize the flex scanner */
         yyscanner = scanner_init(str, &yyextra.core_yy_extra,
                                  ScanKeywords, NumScanKeywords);
     
         /* base_yylex() only needs this much initialization */
         yyextra.have_lookahead = false;
     
         /* initialize the bison parser */
         parser_init(&yyextra);
     
         /* Parse! */
         yyresult = base_yyparse(yyscanner);
     
         /* Clean up (release memory) */
         scanner_finish(yyscanner);
     
         if (yyresult)               /* error */
             return NIL;
     
         return yyextra.parsetree;
     }
    

_5、CreateCommandTag_

    
    
    //创建命令Tag
    //基本上，所有的PG命令类型都可以在这里找到
     /*
      * CreateCommandTag
      *      utility to get a string representation of the command operation,
      *      given either a raw (un-analyzed) parsetree, an analyzed Query,
      *      or a PlannedStmt.
      *
      * This must handle all command types, but since the vast majority
      * of 'em are utility commands, it seems sensible to keep it here.
      *
      * NB: all result strings must be shorter than COMPLETION_TAG_BUFSIZE.
      * Also, the result must point at a true constant (permanent storage).
      */
     const char *
     CreateCommandTag(Node *parsetree)
     {
         const char *tag;
     
         switch (nodeTag(parsetree))
         {
                 /* recurse if we're given a RawStmt */
             case T_RawStmt:
                 tag = CreateCommandTag(((RawStmt *) parsetree)->stmt);
                 break;
     
                 /* raw plannable queries */
             case T_InsertStmt:
                 tag = "INSERT";
                 break;
     
             case T_DeleteStmt:
                 tag = "DELETE";
                 break;
     
             case T_UpdateStmt:
                 tag = "UPDATE";
                 break;
     
             case T_SelectStmt:
                 tag = "SELECT";
                 break;
     
                 /* utility statements --- same whether raw or cooked */
             case T_TransactionStmt:
                 {
                     TransactionStmt *stmt = (TransactionStmt *) parsetree;
     
                     switch (stmt->kind)
                     {
                         case TRANS_STMT_BEGIN:
                             tag = "BEGIN";
                             break;
     
                         case TRANS_STMT_START:
                             tag = "START TRANSACTION";
                             break;
     
                         case TRANS_STMT_COMMIT:
                             tag = "COMMIT";
                             break;
     
                         case TRANS_STMT_ROLLBACK:
                         case TRANS_STMT_ROLLBACK_TO:
                             tag = "ROLLBACK";
                             break;
     
                         case TRANS_STMT_SAVEPOINT:
                             tag = "SAVEPOINT";
                             break;
     
                         case TRANS_STMT_RELEASE:
                             tag = "RELEASE";
                             break;
     
                         case TRANS_STMT_PREPARE:
                             tag = "PREPARE TRANSACTION";
                             break;
     
                         case TRANS_STMT_COMMIT_PREPARED:
                             tag = "COMMIT PREPARED";
                             break;
     
                         case TRANS_STMT_ROLLBACK_PREPARED:
                             tag = "ROLLBACK PREPARED";
                             break;
     
                         default:
                             tag = "???";
                             break;
                     }
                 }
                 break;
     
             case T_DeclareCursorStmt:
                 tag = "DECLARE CURSOR";
                 break;
     
             case T_ClosePortalStmt:
                 {
                     ClosePortalStmt *stmt = (ClosePortalStmt *) parsetree;
     
                     if (stmt->portalname == NULL)
                         tag = "CLOSE CURSOR ALL";
                     else
                         tag = "CLOSE CURSOR";
                 }
                 break;
     
             case T_FetchStmt:
                 {
                     FetchStmt  *stmt = (FetchStmt *) parsetree;
     
                     tag = (stmt->ismove) ? "MOVE" : "FETCH";
                 }
                 break;
     
             case T_CreateDomainStmt:
                 tag = "CREATE DOMAIN";
                 break;
     
             case T_CreateSchemaStmt:
                 tag = "CREATE SCHEMA";
                 break;
     
             case T_CreateStmt:
                 tag = "CREATE TABLE";
                 break;
     
             case T_CreateTableSpaceStmt:
                 tag = "CREATE TABLESPACE";
                 break;
     
             case T_DropTableSpaceStmt:
                 tag = "DROP TABLESPACE";
                 break;
     
             case T_AlterTableSpaceOptionsStmt:
                 tag = "ALTER TABLESPACE";
                 break;
     
             case T_CreateExtensionStmt:
                 tag = "CREATE EXTENSION";
                 break;
     
             case T_AlterExtensionStmt:
                 tag = "ALTER EXTENSION";
                 break;
     
             case T_AlterExtensionContentsStmt:
                 tag = "ALTER EXTENSION";
                 break;
     
             case T_CreateFdwStmt:
                 tag = "CREATE FOREIGN DATA WRAPPER";
                 break;
     
             case T_AlterFdwStmt:
                 tag = "ALTER FOREIGN DATA WRAPPER";
                 break;
     
             case T_CreateForeignServerStmt:
                 tag = "CREATE SERVER";
                 break;
     
             case T_AlterForeignServerStmt:
                 tag = "ALTER SERVER";
                 break;
     
             case T_CreateUserMappingStmt:
                 tag = "CREATE USER MAPPING";
                 break;
     
             case T_AlterUserMappingStmt:
                 tag = "ALTER USER MAPPING";
                 break;
     
             case T_DropUserMappingStmt:
                 tag = "DROP USER MAPPING";
                 break;
     
             case T_CreateForeignTableStmt:
                 tag = "CREATE FOREIGN TABLE";
                 break;
     
             case T_ImportForeignSchemaStmt:
                 tag = "IMPORT FOREIGN SCHEMA";
                 break;
     
             case T_DropStmt:
                 switch (((DropStmt *) parsetree)->removeType)
                 {
                     case OBJECT_TABLE:
                         tag = "DROP TABLE";
                         break;
                     case OBJECT_SEQUENCE:
                         tag = "DROP SEQUENCE";
                         break;
                     case OBJECT_VIEW:
                         tag = "DROP VIEW";
                         break;
                     case OBJECT_MATVIEW:
                         tag = "DROP MATERIALIZED VIEW";
                         break;
                     case OBJECT_INDEX:
                         tag = "DROP INDEX";
                         break;
                     case OBJECT_TYPE:
                         tag = "DROP TYPE";
                         break;
                     case OBJECT_DOMAIN:
                         tag = "DROP DOMAIN";
                         break;
                     case OBJECT_COLLATION:
                         tag = "DROP COLLATION";
                         break;
                     case OBJECT_CONVERSION:
                         tag = "DROP CONVERSION";
                         break;
                     case OBJECT_SCHEMA:
                         tag = "DROP SCHEMA";
                         break;
                     case OBJECT_TSPARSER:
                         tag = "DROP TEXT SEARCH PARSER";
                         break;
                     case OBJECT_TSDICTIONARY:
                         tag = "DROP TEXT SEARCH DICTIONARY";
                         break;
                     case OBJECT_TSTEMPLATE:
                         tag = "DROP TEXT SEARCH TEMPLATE";
                         break;
                     case OBJECT_TSCONFIGURATION:
                         tag = "DROP TEXT SEARCH CONFIGURATION";
                         break;
                     case OBJECT_FOREIGN_TABLE:
                         tag = "DROP FOREIGN TABLE";
                         break;
                     case OBJECT_EXTENSION:
                         tag = "DROP EXTENSION";
                         break;
                     case OBJECT_FUNCTION:
                         tag = "DROP FUNCTION";
                         break;
                     case OBJECT_PROCEDURE:
                         tag = "DROP PROCEDURE";
                         break;
                     case OBJECT_ROUTINE:
                         tag = "DROP ROUTINE";
                         break;
                     case OBJECT_AGGREGATE:
                         tag = "DROP AGGREGATE";
                         break;
                     case OBJECT_OPERATOR:
                         tag = "DROP OPERATOR";
                         break;
                     case OBJECT_LANGUAGE:
                         tag = "DROP LANGUAGE";
                         break;
                     case OBJECT_CAST:
                         tag = "DROP CAST";
                         break;
                     case OBJECT_TRIGGER:
                         tag = "DROP TRIGGER";
                         break;
                     case OBJECT_EVENT_TRIGGER:
                         tag = "DROP EVENT TRIGGER";
                         break;
                     case OBJECT_RULE:
                         tag = "DROP RULE";
                         break;
                     case OBJECT_FDW:
                         tag = "DROP FOREIGN DATA WRAPPER";
                         break;
                     case OBJECT_FOREIGN_SERVER:
                         tag = "DROP SERVER";
                         break;
                     case OBJECT_OPCLASS:
                         tag = "DROP OPERATOR CLASS";
                         break;
                     case OBJECT_OPFAMILY:
                         tag = "DROP OPERATOR FAMILY";
                         break;
                     case OBJECT_POLICY:
                         tag = "DROP POLICY";
                         break;
                     case OBJECT_TRANSFORM:
                         tag = "DROP TRANSFORM";
                         break;
                     case OBJECT_ACCESS_METHOD:
                         tag = "DROP ACCESS METHOD";
                         break;
                     case OBJECT_PUBLICATION:
                         tag = "DROP PUBLICATION";
                         break;
                     case OBJECT_STATISTIC_EXT:
                         tag = "DROP STATISTICS";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_TruncateStmt:
                 tag = "TRUNCATE TABLE";
                 break;
     
             case T_CommentStmt:
                 tag = "COMMENT";
                 break;
     
             case T_SecLabelStmt:
                 tag = "SECURITY LABEL";
                 break;
     
             case T_CopyStmt:
                 tag = "COPY";
                 break;
     
             case T_RenameStmt:
                 tag = AlterObjectTypeCommandTag(((RenameStmt *) parsetree)->renameType);
                 break;
     
             case T_AlterObjectDependsStmt:
                 tag = AlterObjectTypeCommandTag(((AlterObjectDependsStmt *) parsetree)->objectType);
                 break;
     
             case T_AlterObjectSchemaStmt:
                 tag = AlterObjectTypeCommandTag(((AlterObjectSchemaStmt *) parsetree)->objectType);
                 break;
     
             case T_AlterOwnerStmt:
                 tag = AlterObjectTypeCommandTag(((AlterOwnerStmt *) parsetree)->objectType);
                 break;
     
             case T_AlterTableMoveAllStmt:
                 tag = AlterObjectTypeCommandTag(((AlterTableMoveAllStmt *) parsetree)->objtype);
                 break;
     
             case T_AlterTableStmt:
                 tag = AlterObjectTypeCommandTag(((AlterTableStmt *) parsetree)->relkind);
                 break;
     
             case T_AlterDomainStmt:
                 tag = "ALTER DOMAIN";
                 break;
     
             case T_AlterFunctionStmt:
                 switch (((AlterFunctionStmt *) parsetree)->objtype)
                 {
                     case OBJECT_FUNCTION:
                         tag = "ALTER FUNCTION";
                         break;
                     case OBJECT_PROCEDURE:
                         tag = "ALTER PROCEDURE";
                         break;
                     case OBJECT_ROUTINE:
                         tag = "ALTER ROUTINE";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_GrantStmt:
                 {
                     GrantStmt  *stmt = (GrantStmt *) parsetree;
     
                     tag = (stmt->is_grant) ? "GRANT" : "REVOKE";
                 }
                 break;
     
             case T_GrantRoleStmt:
                 {
                     GrantRoleStmt *stmt = (GrantRoleStmt *) parsetree;
     
                     tag = (stmt->is_grant) ? "GRANT ROLE" : "REVOKE ROLE";
                 }
                 break;
     
             case T_AlterDefaultPrivilegesStmt:
                 tag = "ALTER DEFAULT PRIVILEGES";
                 break;
     
             case T_DefineStmt:
                 switch (((DefineStmt *) parsetree)->kind)
                 {
                     case OBJECT_AGGREGATE:
                         tag = "CREATE AGGREGATE";
                         break;
                     case OBJECT_OPERATOR:
                         tag = "CREATE OPERATOR";
                         break;
                     case OBJECT_TYPE:
                         tag = "CREATE TYPE";
                         break;
                     case OBJECT_TSPARSER:
                         tag = "CREATE TEXT SEARCH PARSER";
                         break;
                     case OBJECT_TSDICTIONARY:
                         tag = "CREATE TEXT SEARCH DICTIONARY";
                         break;
                     case OBJECT_TSTEMPLATE:
                         tag = "CREATE TEXT SEARCH TEMPLATE";
                         break;
                     case OBJECT_TSCONFIGURATION:
                         tag = "CREATE TEXT SEARCH CONFIGURATION";
                         break;
                     case OBJECT_COLLATION:
                         tag = "CREATE COLLATION";
                         break;
                     case OBJECT_ACCESS_METHOD:
                         tag = "CREATE ACCESS METHOD";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_CompositeTypeStmt:
                 tag = "CREATE TYPE";
                 break;
     
             case T_CreateEnumStmt:
                 tag = "CREATE TYPE";
                 break;
     
             case T_CreateRangeStmt:
                 tag = "CREATE TYPE";
                 break;
     
             case T_AlterEnumStmt:
                 tag = "ALTER TYPE";
                 break;
     
             case T_ViewStmt:
                 tag = "CREATE VIEW";
                 break;
     
             case T_CreateFunctionStmt:
                 if (((CreateFunctionStmt *) parsetree)->is_procedure)
                     tag = "CREATE PROCEDURE";
                 else
                     tag = "CREATE FUNCTION";
                 break;
     
             case T_IndexStmt:
                 tag = "CREATE INDEX";
                 break;
     
             case T_RuleStmt:
                 tag = "CREATE RULE";
                 break;
     
             case T_CreateSeqStmt:
                 tag = "CREATE SEQUENCE";
                 break;
     
             case T_AlterSeqStmt:
                 tag = "ALTER SEQUENCE";
                 break;
     
             case T_DoStmt:
                 tag = "DO";
                 break;
     
             case T_CreatedbStmt:
                 tag = "CREATE DATABASE";
                 break;
     
             case T_AlterDatabaseStmt:
                 tag = "ALTER DATABASE";
                 break;
     
             case T_AlterDatabaseSetStmt:
                 tag = "ALTER DATABASE";
                 break;
     
             case T_DropdbStmt:
                 tag = "DROP DATABASE";
                 break;
     
             case T_NotifyStmt:
                 tag = "NOTIFY";
                 break;
     
             case T_ListenStmt:
                 tag = "LISTEN";
                 break;
     
             case T_UnlistenStmt:
                 tag = "UNLISTEN";
                 break;
     
             case T_LoadStmt:
                 tag = "LOAD";
                 break;
     
             case T_CallStmt:
                 tag = "CALL";
                 break;
     
             case T_ClusterStmt:
                 tag = "CLUSTER";
                 break;
     
             case T_VacuumStmt:
                 if (((VacuumStmt *) parsetree)->options & VACOPT_VACUUM)
                     tag = "VACUUM";
                 else
                     tag = "ANALYZE";
                 break;
     
             case T_ExplainStmt:
                 tag = "EXPLAIN";
                 break;
     
             case T_CreateTableAsStmt:
                 switch (((CreateTableAsStmt *) parsetree)->relkind)
                 {
                     case OBJECT_TABLE:
                         if (((CreateTableAsStmt *) parsetree)->is_select_into)
                             tag = "SELECT INTO";
                         else
                             tag = "CREATE TABLE AS";
                         break;
                     case OBJECT_MATVIEW:
                         tag = "CREATE MATERIALIZED VIEW";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_RefreshMatViewStmt:
                 tag = "REFRESH MATERIALIZED VIEW";
                 break;
     
             case T_AlterSystemStmt:
                 tag = "ALTER SYSTEM";
                 break;
     
             case T_VariableSetStmt:
                 switch (((VariableSetStmt *) parsetree)->kind)
                 {
                     case VAR_SET_VALUE:
                     case VAR_SET_CURRENT:
                     case VAR_SET_DEFAULT:
                     case VAR_SET_MULTI:
                         tag = "SET";
                         break;
                     case VAR_RESET:
                     case VAR_RESET_ALL:
                         tag = "RESET";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_VariableShowStmt:
                 tag = "SHOW";
                 break;
     
             case T_DiscardStmt:
                 switch (((DiscardStmt *) parsetree)->target)
                 {
                     case DISCARD_ALL:
                         tag = "DISCARD ALL";
                         break;
                     case DISCARD_PLANS:
                         tag = "DISCARD PLANS";
                         break;
                     case DISCARD_TEMP:
                         tag = "DISCARD TEMP";
                         break;
                     case DISCARD_SEQUENCES:
                         tag = "DISCARD SEQUENCES";
                         break;
                     default:
                         tag = "???";
                 }
                 break;
     
             case T_CreateTransformStmt:
                 tag = "CREATE TRANSFORM";
                 break;
     
             case T_CreateTrigStmt:
                 tag = "CREATE TRIGGER";
                 break;
     
             case T_CreateEventTrigStmt:
                 tag = "CREATE EVENT TRIGGER";
                 break;
     
             case T_AlterEventTrigStmt:
                 tag = "ALTER EVENT TRIGGER";
                 break;
     
             case T_CreatePLangStmt:
                 tag = "CREATE LANGUAGE";
                 break;
     
             case T_CreateRoleStmt:
                 tag = "CREATE ROLE";
                 break;
     
             case T_AlterRoleStmt:
                 tag = "ALTER ROLE";
                 break;
     
             case T_AlterRoleSetStmt:
                 tag = "ALTER ROLE";
                 break;
     
             case T_DropRoleStmt:
                 tag = "DROP ROLE";
                 break;
     
             case T_DropOwnedStmt:
                 tag = "DROP OWNED";
                 break;
     
             case T_ReassignOwnedStmt:
                 tag = "REASSIGN OWNED";
                 break;
     
             case T_LockStmt:
                 tag = "LOCK TABLE";
                 break;
     
             case T_ConstraintsSetStmt:
                 tag = "SET CONSTRAINTS";
                 break;
     
             case T_CheckPointStmt:
                 tag = "CHECKPOINT";
                 break;
     
             case T_ReindexStmt:
                 tag = "REINDEX";
                 break;
     
             case T_CreateConversionStmt:
                 tag = "CREATE CONVERSION";
                 break;
     
             case T_CreateCastStmt:
                 tag = "CREATE CAST";
                 break;
     
             case T_CreateOpClassStmt:
                 tag = "CREATE OPERATOR CLASS";
                 break;
     
             case T_CreateOpFamilyStmt:
                 tag = "CREATE OPERATOR FAMILY";
                 break;
     
             case T_AlterOpFamilyStmt:
                 tag = "ALTER OPERATOR FAMILY";
                 break;
     
             case T_AlterOperatorStmt:
                 tag = "ALTER OPERATOR";
                 break;
     
             case T_AlterTSDictionaryStmt:
                 tag = "ALTER TEXT SEARCH DICTIONARY";
                 break;
     
             case T_AlterTSConfigurationStmt:
                 tag = "ALTER TEXT SEARCH CONFIGURATION";
                 break;
     
             case T_CreatePolicyStmt:
                 tag = "CREATE POLICY";
                 break;
     
             case T_AlterPolicyStmt:
                 tag = "ALTER POLICY";
                 break;
     
             case T_CreateAmStmt:
                 tag = "CREATE ACCESS METHOD";
                 break;
     
             case T_CreatePublicationStmt:
                 tag = "CREATE PUBLICATION";
                 break;
     
             case T_AlterPublicationStmt:
                 tag = "ALTER PUBLICATION";
                 break;
     
             case T_CreateSubscriptionStmt:
                 tag = "CREATE SUBSCRIPTION";
                 break;
     
             case T_AlterSubscriptionStmt:
                 tag = "ALTER SUBSCRIPTION";
                 break;
     
             case T_DropSubscriptionStmt:
                 tag = "DROP SUBSCRIPTION";
                 break;
     
             case T_AlterCollationStmt:
                 tag = "ALTER COLLATION";
                 break;
     
             case T_PrepareStmt:
                 tag = "PREPARE";
                 break;
     
             case T_ExecuteStmt:
                 tag = "EXECUTE";
                 break;
     
             case T_CreateStatsStmt:
                 tag = "CREATE STATISTICS";
                 break;
     
             case T_DeallocateStmt:
                 {
                     DeallocateStmt *stmt = (DeallocateStmt *) parsetree;
     
                     if (stmt->name == NULL)
                         tag = "DEALLOCATE ALL";
                     else
                         tag = "DEALLOCATE";
                 }
                 break;
     
                 /* already-planned queries */
             case T_PlannedStmt:
                 {
                     PlannedStmt *stmt = (PlannedStmt *) parsetree;
     
                     switch (stmt->commandType)
                     {
                         case CMD_SELECT:
     
                             /*
                              * We take a little extra care here so that the result
                              * will be useful for complaints about read-only
                              * statements
                              */
                             if (stmt->rowMarks != NIL)
                             {
                                 /* not 100% but probably close enough */
                                 switch (((PlanRowMark *) linitial(stmt->rowMarks))->strength)
                                 {
                                     case LCS_FORKEYSHARE:
                                         tag = "SELECT FOR KEY SHARE";
                                         break;
                                     case LCS_FORSHARE:
                                         tag = "SELECT FOR SHARE";
                                         break;
                                     case LCS_FORNOKEYUPDATE:
                                         tag = "SELECT FOR NO KEY UPDATE";
                                         break;
                                     case LCS_FORUPDATE:
                                         tag = "SELECT FOR UPDATE";
                                         break;
                                     default:
                                         tag = "SELECT";
                                         break;
                                 }
                             }
                             else
                                 tag = "SELECT";
                             break;
                         case CMD_UPDATE:
                             tag = "UPDATE";
                             break;
                         case CMD_INSERT:
                             tag = "INSERT";
                             break;
                         case CMD_DELETE:
                             tag = "DELETE";
                             break;
                         case CMD_UTILITY:
                             tag = CreateCommandTag(stmt->utilityStmt);
                             break;
                         default:
                             elog(WARNING, "unrecognized commandType: %d",
                                  (int) stmt->commandType);
                             tag = "???";
                             break;
                     }
                 }
                 break;
     
                 /* parsed-and-rewritten-but-not-planned queries */
             case T_Query:
                 {
                     Query      *stmt = (Query *) parsetree;
     
                     switch (stmt->commandType)
                     {
                         case CMD_SELECT:
     
                             /*
                              * We take a little extra care here so that the result
                              * will be useful for complaints about read-only
                              * statements
                              */
                             if (stmt->rowMarks != NIL)
                             {
                                 /* not 100% but probably close enough */
                                 switch (((RowMarkClause *) linitial(stmt->rowMarks))->strength)
                                 {
                                     case LCS_FORKEYSHARE:
                                         tag = "SELECT FOR KEY SHARE";
                                         break;
                                     case LCS_FORSHARE:
                                         tag = "SELECT FOR SHARE";
                                         break;
                                     case LCS_FORNOKEYUPDATE:
                                         tag = "SELECT FOR NO KEY UPDATE";
                                         break;
                                     case LCS_FORUPDATE:
                                         tag = "SELECT FOR UPDATE";
                                         break;
                                     default:
                                         tag = "???";
                                         break;
                                 }
                             }
                             else
                                 tag = "SELECT";
                             break;
                         case CMD_UPDATE:
                             tag = "UPDATE";
                             break;
                         case CMD_INSERT:
                             tag = "INSERT";
                             break;
                         case CMD_DELETE:
                             tag = "DELETE";
                             break;
                         case CMD_UTILITY:
                             tag = CreateCommandTag(stmt->utilityStmt);
                             break;
                         default:
                             elog(WARNING, "unrecognized commandType: %d",
                                  (int) stmt->commandType);
                             tag = "???";
                             break;
                     }
                 }
                 break;
     
             default:
                 elog(WARNING, "unrecognized node type: %d",
                      (int) nodeTag(parsetree));
                 tag = "???";
                 break;
         }
     
         return tag;
     }
    
    

_6、BeginCommand_

    
    
     /* ----------------      *      BeginCommand - initialize the destination at start of command
      * ----------------      */
     void
     BeginCommand(const char *commandTag, CommandDest dest)
     {
         /* Nothing to do at present */
     }
     
    

_7、analyze_requires_snapshot_

    
    
    //是否需要快照？
    //增删改查均需要
     /*
      * analyze_requires_snapshot
      *      Returns true if a snapshot must be set before doing parse analysis
      *      on the given raw parse tree.
      *
      * Classification here should match transformStmt().
      */
     bool
     analyze_requires_snapshot(RawStmt *parseTree)
     {
         bool        result;
     
         switch (nodeTag(parseTree->stmt))
         {
                 /*
                  * Optimizable statements
                  */
             case T_InsertStmt:
             case T_DeleteStmt:
             case T_UpdateStmt:
             case T_SelectStmt:
                 result = true;
                 break;
     
                 /*
                  * Special cases
                  */
             case T_DeclareCursorStmt:
             case T_ExplainStmt:
             case T_CreateTableAsStmt:
                 /* yes, because we must analyze the contained statement */
                 result = true;
                 break;
     
             default:
                 /* other utility statements don't have any real parse analysis */
                 result = false;
                 break;
         }
     
         return result;
     }
     
    

_8、pg_analyze_and_rewrite_

    
    
     /*
      * Given a raw parsetree (gram.y output), and optionally information about
      * types of parameter symbols ($n), perform parse analysis and rule rewriting.
      *
      * A list of Query nodes is returned, since either the analyzer or the
      * rewriter might expand one query to several.
      *
      * NOTE: for reasons mentioned above, this must be separate from raw parsing.
      */
     List *
     pg_analyze_and_rewrite(RawStmt *parsetree, const char *query_string,
                            Oid *paramTypes, int numParams,
                            QueryEnvironment *queryEnv)
     {
         Query      *query;
         List       *querytree_list;
     
         TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);
     
         /*
          * (1) Perform parse analysis.
          */
         if (log_parser_stats)
             ResetUsage();
     
         query = parse_analyze(parsetree, query_string, paramTypes, numParams,
                               queryEnv);//解析&分析
     
         if (log_parser_stats)
             ShowUsage("PARSE ANALYSIS STATISTICS");
     
         /*
          * (2) Rewrite the queries, as necessary
          */
         querytree_list = pg_rewrite_query(query);//查询重写
     
         TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);
     
         return querytree_list;
     }
     
     /*
      * parse_analyze
      *      Analyze a raw parse tree and transform it to Query form.
      *
      * Optionally, information about $n parameter types can be supplied.
      * References to $n indexes not defined by paramTypes[] are disallowed.
      *
      * The result is a Query node.  Optimizable statements require considerable
      * transformation, while utility-type statements are simply hung off
      * a dummy CMD_UTILITY Query node.
      */
     Query *
     parse_analyze(RawStmt *parseTree, const char *sourceText,
                   Oid *paramTypes, int numParams,
                   QueryEnvironment *queryEnv)
     {
         ParseState *pstate = make_parsestate(NULL);
         Query      *query;
     
         Assert(sourceText != NULL); /* required as of 8.4 */
     
         pstate->p_sourcetext = sourceText;
     
         if (numParams > 0)
             parse_fixed_parameters(pstate, paramTypes, numParams);
     
         pstate->p_queryEnv = queryEnv;
     
         query = transformTopLevelStmt(pstate, parseTree);
     
         if (post_parse_analyze_hook)
             (*post_parse_analyze_hook) (pstate, query);
     
         free_parsestate(pstate);
     
         return query;
     }
    
     /*
      * make_parsestate
      *      Allocate and initialize a new ParseState.
      *
      * Caller should eventually release the ParseState via free_parsestate().
      */
     ParseState *
     make_parsestate(ParseState *parentParseState)
     {
         ParseState *pstate;
     
         pstate = palloc0(sizeof(ParseState));
     
         pstate->parentParseState = parentParseState;
     
         /* Fill in fields that don't start at null/false/zero */
         pstate->p_next_resno = 1;
         pstate->p_resolve_unknowns = true;
     
         if (parentParseState)
         {
             pstate->p_sourcetext = parentParseState->p_sourcetext;
             /* all hooks are copied from parent */
             pstate->p_pre_columnref_hook = parentParseState->p_pre_columnref_hook;
             pstate->p_post_columnref_hook = parentParseState->p_post_columnref_hook;
             pstate->p_paramref_hook = parentParseState->p_paramref_hook;
             pstate->p_coerce_param_hook = parentParseState->p_coerce_param_hook;
             pstate->p_ref_hook_state = parentParseState->p_ref_hook_state;
             /* query environment stays in context for the whole parse analysis */
             pstate->p_queryEnv = parentParseState->p_queryEnv;
         }
     
         return pstate;
     }
    
     /*
      * transformTopLevelStmt -      *    transform a Parse tree into a Query tree.
      *
      * This function is just responsible for transferring statement location data
      * from the RawStmt into the finished Query.
      */
     Query *
     transformTopLevelStmt(ParseState *pstate, RawStmt *parseTree)
     {
         Query      *result;
     
         /* We're at top level, so allow SELECT INTO */
         result = transformOptionalSelectInto(pstate, parseTree->stmt);
     
         result->stmt_location = parseTree->stmt_location;
         result->stmt_len = parseTree->stmt_len;
     
         return result;
     }
    
    /*
      * transformOptionalSelectInto -      *    If SELECT has INTO, convert it to CREATE TABLE AS.
      *
      * The only thing we do here that we don't do in transformStmt() is to
      * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements
      * aren't allowed within larger statements, this is only allowed at the top
      * of the parse tree, and so we only try it before entering the recursive
      * transformStmt() processing.
      */
     static Query *
     transformOptionalSelectInto(ParseState *pstate, Node *parseTree)
     {
         if (IsA(parseTree, SelectStmt))
         {
             SelectStmt *stmt = (SelectStmt *) parseTree;
     
             /* If it's a set-operation tree, drill down to leftmost SelectStmt */
             while (stmt && stmt->op != SETOP_NONE)
                 stmt = stmt->larg;
             Assert(stmt && IsA(stmt, SelectStmt) &&stmt->larg == NULL);
     
             if (stmt->intoClause)
             {
                 CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
     
                 ctas->query = parseTree;
                 ctas->into = stmt->intoClause;
                 ctas->relkind = OBJECT_TABLE;
                 ctas->is_select_into = true;
     
                 /*
                  * Remove the intoClause from the SelectStmt.  This makes it safe
                  * for transformSelectStmt to complain if it finds intoClause set
                  * (implying that the INTO appeared in a disallowed place).
                  */
                 stmt->intoClause = NULL;
     
                 parseTree = (Node *) ctas;
             }
         }
     
         return transformStmt(pstate, parseTree);
     }
     
     /*
      * transformStmt -      *    recursively transform a Parse tree into a Query tree.
      */
     Query *
     transformStmt(ParseState *pstate, Node *parseTree)
     {
         Query      *result;
     
         /*
          * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;
          * we can't just run it on everything because raw_expression_tree_walker()
          * doesn't claim to handle utility statements.
          */
     #ifdef RAW_EXPRESSION_COVERAGE_TEST
         switch (nodeTag(parseTree))
         {
             case T_SelectStmt:
             case T_InsertStmt:
             case T_UpdateStmt:
             case T_DeleteStmt:
                 (void) test_raw_expression_coverage(parseTree, NULL);
                 break;
             default:
                 break;
         }
     #endif                          /* RAW_EXPRESSION_COVERAGE_TEST */
     
         switch (nodeTag(parseTree))
         {
                 /*
                  * Optimizable statements
                  */
             case T_InsertStmt:
                 result = transformInsertStmt(pstate, (InsertStmt *) parseTree);
                 break;
     
             case T_DeleteStmt:
                 result = transformDeleteStmt(pstate, (DeleteStmt *) parseTree);
                 break;
     
             case T_UpdateStmt:
                 result = transformUpdateStmt(pstate, (UpdateStmt *) parseTree);
                 break;
     
             case T_SelectStmt:
                 {
                     SelectStmt *n = (SelectStmt *) parseTree;
     
                     if (n->valuesLists)
                         result = transformValuesClause(pstate, n);
                     else if (n->op == SETOP_NONE)
                         result = transformSelectStmt(pstate, n);
                     else
                         result = transformSetOperationStmt(pstate, n);
                 }
                 break;
     
                 /*
                  * Special cases
                  */
             case T_DeclareCursorStmt:
                 result = transformDeclareCursorStmt(pstate,
                                                     (DeclareCursorStmt *) parseTree);
                 break;
     
             case T_ExplainStmt:
                 result = transformExplainStmt(pstate,
                                               (ExplainStmt *) parseTree);
                 break;
     
             case T_CreateTableAsStmt:
                 result = transformCreateTableAsStmt(pstate,
                                                     (CreateTableAsStmt *) parseTree);
                 break;
     
             case T_CallStmt:
                 result = transformCallStmt(pstate,
                                            (CallStmt *) parseTree);
                 break;
     
             default:
     
                 /*
                  * other statements don't require any transformation; just return
                  * the original parsetree with a Query node plastered on top.
                  */
                 result = makeNode(Query);
                 result->commandType = CMD_UTILITY;
                 result->utilityStmt = (Node *) parseTree;
                 break;
         }
     
         /* Mark as original query until we learn differently */
         result->querySource = QSRC_ORIGINAL;
         result->canSetTag = true;
     
         return result;
     }
    
     /*
      * transformInsertStmt -      *    transform an Insert Statement
      */
     static Query *
     transformInsertStmt(ParseState *pstate, InsertStmt *stmt)
     {
         Query      *qry = makeNode(Query);
         SelectStmt *selectStmt = (SelectStmt *) stmt->selectStmt;
         List       *exprList = NIL;
         bool        isGeneralSelect;
         List       *sub_rtable;
         List       *sub_namespace;
         List       *icolumns;
         List       *attrnos;
         RangeTblEntry *rte;
         RangeTblRef *rtr;
         ListCell   *icols;
         ListCell   *attnos;
         ListCell   *lc;
         bool        isOnConflictUpdate;
         AclMode     targetPerms;
     
         /* There can't be any outer WITH to worry about */
         Assert(pstate->p_ctenamespace == NIL);
     
         qry->commandType = CMD_INSERT;
         pstate->p_is_insert = true;
     
         /* process the WITH clause independently of all else */
         if (stmt->withClause)
         {
             qry->hasRecursive = stmt->withClause->recursive;
             qry->cteList = transformWithClause(pstate, stmt->withClause);
             qry->hasModifyingCTE = pstate->p_hasModifyingCTE;
         }
     
         qry->override = stmt->override;
     
         isOnConflictUpdate = (stmt->onConflictClause &&
                               stmt->onConflictClause->action == ONCONFLICT_UPDATE);
     
         /*
          * We have three cases to deal with: DEFAULT VALUES (selectStmt == NULL),
          * VALUES list, or general SELECT input.  We special-case VALUES, both for
          * efficiency and so we can handle DEFAULT specifications.
          *
          * The grammar allows attaching ORDER BY, LIMIT, FOR UPDATE, or WITH to a
          * VALUES clause.  If we have any of those, treat it as a general SELECT;
          * so it will work, but you can't use DEFAULT items together with those.
          */
         isGeneralSelect = (selectStmt && (selectStmt->valuesLists == NIL ||
                                           selectStmt->sortClause != NIL ||
                                           selectStmt->limitOffset != NULL ||
                                           selectStmt->limitCount != NULL ||
                                           selectStmt->lockingClause != NIL ||
                                           selectStmt->withClause != NULL));
     
         /*
          * If a non-nil rangetable/namespace was passed in, and we are doing
          * INSERT/SELECT, arrange to pass the rangetable/namespace down to the
          * SELECT.  This can only happen if we are inside a CREATE RULE, and in
          * that case we want the rule's OLD and NEW rtable entries to appear as
          * part of the SELECT's rtable, not as outer references for it.  (Kluge!)
          * The SELECT's joinlist is not affected however.  We must do this before
          * adding the target table to the INSERT's rtable.
          */
         if (isGeneralSelect)
         {
             sub_rtable = pstate->p_rtable;
             pstate->p_rtable = NIL;
             sub_namespace = pstate->p_namespace;
             pstate->p_namespace = NIL;
         }
         else
         {
             sub_rtable = NIL;       /* not used, but keep compiler quiet */
             sub_namespace = NIL;
         }
     
         /*
          * Must get write lock on INSERT target table before scanning SELECT, else
          * we will grab the wrong kind of initial lock if the target table is also
          * mentioned in the SELECT part.  Note that the target table is not added
          * to the joinlist or namespace.
          */
         targetPerms = ACL_INSERT;
         if (isOnConflictUpdate)
             targetPerms |= ACL_UPDATE;
         qry->resultRelation = setTargetTable(pstate, stmt->relation,
                                              false, false, targetPerms);
     
         /* Validate stmt->cols list, or build default list if no list given */
         icolumns = checkInsertTargets(pstate, stmt->cols, &attrnos);
         Assert(list_length(icolumns) == list_length(attrnos));
     
         /*
          * Determine which variant of INSERT we have.
          */
         if (selectStmt == NULL)
         {
             /*
              * We have INSERT ... DEFAULT VALUES.  We can handle this case by
              * emitting an empty targetlist --- all columns will be defaulted when
              * the planner expands the targetlist.
              */
             exprList = NIL;
         }
         else if (isGeneralSelect)
         {
             /*
              * We make the sub-pstate a child of the outer pstate so that it can
              * see any Param definitions supplied from above.  Since the outer
              * pstate's rtable and namespace are presently empty, there are no
              * side-effects of exposing names the sub-SELECT shouldn't be able to
              * see.
              */
             ParseState *sub_pstate = make_parsestate(pstate);
             Query      *selectQuery;
     
             /*
              * Process the source SELECT.
              *
              * It is important that this be handled just like a standalone SELECT;
              * otherwise the behavior of SELECT within INSERT might be different
              * from a stand-alone SELECT. (Indeed, Postgres up through 6.5 had
              * bugs of just that nature...)
              *
              * The sole exception is that we prevent resolving unknown-type
              * outputs as TEXT.  This does not change the semantics since if the
              * column type matters semantically, it would have been resolved to
              * something else anyway.  Doing this lets us resolve such outputs as
              * the target column's type, which we handle below.
              */
             sub_pstate->p_rtable = sub_rtable;
             sub_pstate->p_joinexprs = NIL;  /* sub_rtable has no joins */
             sub_pstate->p_namespace = sub_namespace;
             sub_pstate->p_resolve_unknowns = false;
     
             selectQuery = transformStmt(sub_pstate, stmt->selectStmt);
     
             free_parsestate(sub_pstate);
     
             /* The grammar should have produced a SELECT */
             if (!IsA(selectQuery, Query) ||
                 selectQuery->commandType != CMD_SELECT)
                 elog(ERROR, "unexpected non-SELECT command in INSERT ... SELECT");
     
             /*
              * Make the source be a subquery in the INSERT's rangetable, and add
              * it to the INSERT's joinlist.
              */
             rte = addRangeTableEntryForSubquery(pstate,
                                                 selectQuery,
                                                 makeAlias("*SELECT*", NIL),
                                                 false,
                                                 false);
             rtr = makeNode(RangeTblRef);
             /* assume new rte is at end */
             rtr->rtindex = list_length(pstate->p_rtable);
             Assert(rte == rt_fetch(rtr->rtindex, pstate->p_rtable));
             pstate->p_joinlist = lappend(pstate->p_joinlist, rtr);
     
             /*----------              * Generate an expression list for the INSERT that selects all the
              * non-resjunk columns from the subquery.  (INSERT's tlist must be
              * separate from the subquery's tlist because we may add columns,
              * insert datatype coercions, etc.)
              *
              * HACK: unknown-type constants and params in the SELECT's targetlist
              * are copied up as-is rather than being referenced as subquery
              * outputs.  This is to ensure that when we try to coerce them to
              * the target column's datatype, the right things happen (see
              * special cases in coerce_type).  Otherwise, this fails:
              *      INSERT INTO foo SELECT 'bar', ... FROM baz
              *----------              */
             exprList = NIL;
             foreach(lc, selectQuery->targetList)
             {
                 TargetEntry *tle = (TargetEntry *) lfirst(lc);
                 Expr       *expr;
     
                 if (tle->resjunk)
                     continue;
                 if (tle->expr &&
                     (IsA(tle->expr, Const) ||IsA(tle->expr, Param)) &&
                     exprType((Node *) tle->expr) == UNKNOWNOID)
                     expr = tle->expr;
                 else
                 {
                     Var        *var = makeVarFromTargetEntry(rtr->rtindex, tle);
     
                     var->location = exprLocation((Node *) tle->expr);
                     expr = (Expr *) var;
                 }
                 exprList = lappend(exprList, expr);
             }
     
             /* Prepare row for assignment to target table */
             exprList = transformInsertRow(pstate, exprList,
                                           stmt->cols,
                                           icolumns, attrnos,
                                           false);
         }
         else if (list_length(selectStmt->valuesLists) > 1)
         {
             /*
              * Process INSERT ... VALUES with multiple VALUES sublists. We
              * generate a VALUES RTE holding the transformed expression lists, and
              * build up a targetlist containing Vars that reference the VALUES
              * RTE.
              */
             List       *exprsLists = NIL;
             List       *coltypes = NIL;
             List       *coltypmods = NIL;
             List       *colcollations = NIL;
             int         sublist_length = -1;
             bool        lateral = false;
     
             Assert(selectStmt->intoClause == NULL);
     
             foreach(lc, selectStmt->valuesLists)
             {
                 List       *sublist = (List *) lfirst(lc);
     
                 /*
                  * Do basic expression transformation (same as a ROW() expr, but
                  * allow SetToDefault at top level)
                  */
                 sublist = transformExpressionList(pstate, sublist,
                                                   EXPR_KIND_VALUES, true);
     
                 /*
                  * All the sublists must be the same length, *after*
                  * transformation (which might expand '*' into multiple items).
                  * The VALUES RTE can't handle anything different.
                  */
                 if (sublist_length < 0)
                 {
                     /* Remember post-transformation length of first sublist */
                     sublist_length = list_length(sublist);
                 }
                 else if (sublist_length != list_length(sublist))
                 {
                     ereport(ERROR,
                             (errcode(ERRCODE_SYNTAX_ERROR),
                              errmsg("VALUES lists must all be the same length"),
                              parser_errposition(pstate,
                                                 exprLocation((Node *) sublist))));
                 }
     
                 /*
                  * Prepare row for assignment to target table.  We process any
                  * indirection on the target column specs normally but then strip
                  * off the resulting field/array assignment nodes, since we don't
                  * want the parsed statement to contain copies of those in each
                  * VALUES row.  (It's annoying to have to transform the
                  * indirection specs over and over like this, but avoiding it
                  * would take some really messy refactoring of
                  * transformAssignmentIndirection.)
                  */
                 sublist = transformInsertRow(pstate, sublist,
                                              stmt->cols,
                                              icolumns, attrnos,
                                              true);
     
                 /*
                  * We must assign collations now because assign_query_collations
                  * doesn't process rangetable entries.  We just assign all the
                  * collations independently in each row, and don't worry about
                  * whether they are consistent vertically.  The outer INSERT query
                  * isn't going to care about the collations of the VALUES columns,
                  * so it's not worth the effort to identify a common collation for
                  * each one here.  (But note this does have one user-visible
                  * consequence: INSERT ... VALUES won't complain about conflicting
                  * explicit COLLATEs in a column, whereas the same VALUES
                  * construct in another context would complain.)
                  */
                 assign_list_collations(pstate, sublist);
     
                 exprsLists = lappend(exprsLists, sublist);
             }
     
             /*
              * Construct column type/typmod/collation lists for the VALUES RTE.
              * Every expression in each column has been coerced to the type/typmod
              * of the corresponding target column or subfield, so it's sufficient
              * to look at the exprType/exprTypmod of the first row.  We don't care
              * about the collation labeling, so just fill in InvalidOid for that.
              */
             foreach(lc, (List *) linitial(exprsLists))
             {
                 Node       *val = (Node *) lfirst(lc);
     
                 coltypes = lappend_oid(coltypes, exprType(val));
                 coltypmods = lappend_int(coltypmods, exprTypmod(val));
                 colcollations = lappend_oid(colcollations, InvalidOid);
             }
     
             /*
              * Ordinarily there can't be any current-level Vars in the expression
              * lists, because the namespace was empty ... but if we're inside
              * CREATE RULE, then NEW/OLD references might appear.  In that case we
              * have to mark the VALUES RTE as LATERAL.
              */
             if (list_length(pstate->p_rtable) != 1 &&
                 contain_vars_of_level((Node *) exprsLists, 0))
                 lateral = true;
     
             /*
              * Generate the VALUES RTE
              */
             rte = addRangeTableEntryForValues(pstate, exprsLists,
                                               coltypes, coltypmods, colcollations,
                                               NULL, lateral, true);
             rtr = makeNode(RangeTblRef);
             /* assume new rte is at end */
             rtr->rtindex = list_length(pstate->p_rtable);
             Assert(rte == rt_fetch(rtr->rtindex, pstate->p_rtable));
             pstate->p_joinlist = lappend(pstate->p_joinlist, rtr);
     
             /*
              * Generate list of Vars referencing the RTE
              */
             expandRTE(rte, rtr->rtindex, 0, -1, false, NULL, &exprList);
     
             /*
              * Re-apply any indirection on the target column specs to the Vars
              */
             exprList = transformInsertRow(pstate, exprList,
                                           stmt->cols,
                                           icolumns, attrnos,
                                           false);
         }
         else
         {
             /*
              * Process INSERT ... VALUES with a single VALUES sublist.  We treat
              * this case separately for efficiency.  The sublist is just computed
              * directly as the Query's targetlist, with no VALUES RTE.  So it
              * works just like a SELECT without any FROM.
              */
             List       *valuesLists = selectStmt->valuesLists;
     
             Assert(list_length(valuesLists) == 1);
             Assert(selectStmt->intoClause == NULL);
     
             /*
              * Do basic expression transformation (same as a ROW() expr, but allow
              * SetToDefault at top level)
              */
             exprList = transformExpressionList(pstate,
                                                (List *) linitial(valuesLists),
                                                EXPR_KIND_VALUES_SINGLE,
                                                true);
     
             /* Prepare row for assignment to target table */
             exprList = transformInsertRow(pstate, exprList,
                                           stmt->cols,
                                           icolumns, attrnos,
                                           false);
         }
     
         /*
          * Generate query's target list using the computed list of expressions.
          * Also, mark all the target columns as needing insert permissions.
          */
         rte = pstate->p_target_rangetblentry;
         qry->targetList = NIL;
         icols = list_head(icolumns);
         attnos = list_head(attrnos);
         foreach(lc, exprList)
         {
             Expr       *expr = (Expr *) lfirst(lc);
             ResTarget  *col;
             AttrNumber  attr_num;
             TargetEntry *tle;
     
             col = lfirst_node(ResTarget, icols);
             attr_num = (AttrNumber) lfirst_int(attnos);
     
             tle = makeTargetEntry(expr,
                                   attr_num,
                                   col->name,
                                   false);
             qry->targetList = lappend(qry->targetList, tle);
     
             rte->insertedCols = bms_add_member(rte->insertedCols,
                                                attr_num - FirstLowInvalidHeapAttributeNumber);
     
             icols = lnext(icols);
             attnos = lnext(attnos);
         }
     
         /* Process ON CONFLICT, if any. */
         if (stmt->onConflictClause)
             qry->onConflict = transformOnConflictClause(pstate,
                                                         stmt->onConflictClause);
     
         /*
          * If we have a RETURNING clause, we need to add the target relation to
          * the query namespace before processing it, so that Var references in
          * RETURNING will work.  Also, remove any namespace entries added in a
          * sub-SELECT or VALUES list.
          */
         if (stmt->returningList)
         {
             pstate->p_namespace = NIL;
             addRTEtoQuery(pstate, pstate->p_target_rangetblentry,
                           false, true, true);
             qry->returningList = transformReturningList(pstate,
                                                         stmt->returningList);
         }
     
         /* done building the range table and jointree */
         qry->rtable = pstate->p_rtable;
         qry->jointree = makeFromExpr(pstate->p_joinlist, NULL);
     
         qry->hasTargetSRFs = pstate->p_hasTargetSRFs;
         qry->hasSubLinks = pstate->p_hasSubLinks;
     
         assign_query_collations(pstate, qry);
     
         return qry;
     }
     
    
    
    

_9、pg_plan_queries_

    
    
     /*
      * Generate plans for a list of already-rewritten queries.
      *
      * For normal optimizable statements, invoke the planner.  For utility
      * statements, just make a wrapper PlannedStmt node.
      *
      * The result is a list of PlannedStmt nodes.
      */
     List *
     pg_plan_queries(List *querytrees, int cursorOptions, ParamListInfo boundParams)
     {
         List       *stmt_list = NIL;
         ListCell   *query_list;
     
         foreach(query_list, querytrees)
         {
             Query      *query = lfirst_node(Query, query_list);
             PlannedStmt *stmt;
     
             if (query->commandType == CMD_UTILITY)
             {
                 /* Utility commands require no planning. */
                 stmt = makeNode(PlannedStmt);
                 stmt->commandType = CMD_UTILITY;
                 stmt->canSetTag = query->canSetTag;
                 stmt->utilityStmt = query->utilityStmt;
                 stmt->stmt_location = query->stmt_location;
                 stmt->stmt_len = query->stmt_len;
             }
             else
             {
                 stmt = pg_plan_query(query, cursorOptions, boundParams);
             }
     
             stmt_list = lappend(stmt_list, stmt);
         }
     
         return stmt_list;
     }
     
    /*
      * Generate a plan for a single already-rewritten query.
      * This is a thin wrapper around planner() and takes the same parameters.
      */
     PlannedStmt *
     pg_plan_query(Query *querytree, int cursorOptions, ParamListInfo boundParams)
     {
         PlannedStmt *plan;
     
         /* Utility commands have no plans. */
         if (querytree->commandType == CMD_UTILITY)
             return NULL;
     
         /* Planner must have a snapshot in case it calls user-defined functions. */
         Assert(ActiveSnapshotSet());
     
         TRACE_POSTGRESQL_QUERY_PLAN_START();
     
         if (log_planner_stats)
             ResetUsage();
     
         /* call the optimizer */
         plan = planner(querytree, cursorOptions, boundParams);
     
         if (log_planner_stats)
             ShowUsage("PLANNER STATISTICS");
     
     #ifdef COPY_PARSE_PLAN_TREES
         /* Optional debugging check: pass plan output through copyObject() */
         {
             PlannedStmt *new_plan = copyObject(plan);
     
             /*
              * equal() currently does not have routines to compare Plan nodes, so
              * don't try to test equality here.  Perhaps fix someday?
              */
     #ifdef NOT_USED
             /* This checks both copyObject() and the equal() routines... */
             if (!equal(new_plan, plan))
                 elog(WARNING, "copyObject() failed to produce an equal plan tree");
             else
     #endif
                 plan = new_plan;
         }
     #endif
     
         /*
          * Print plan if debugging.
          */
         if (Debug_print_plan)
             elog_node_display(LOG, "plan", plan, Debug_pretty_print);
     
         TRACE_POSTGRESQL_QUERY_PLAN_DONE();
     
         return plan;
     }
    
     /*****************************************************************************
      *
      *     Query optimizer entry point
      *
      * To support loadable plugins that monitor or modify planner behavior,
      * we provide a hook variable that lets a plugin get control before and
      * after the standard planning process.  The plugin would normally call
      * standard_planner().
      *
      * Note to plugin authors: standard_planner() scribbles on its Query input,
      * so you'd better copy that data structure if you want to plan more than once.
      *
      *****************************************************************************/
     PlannedStmt *
     planner(Query *parse, int cursorOptions, ParamListInfo boundParams)
     {
         PlannedStmt *result;
     
         if (planner_hook)
             result = (*planner_hook) (parse, cursorOptions, boundParams);
         else
             result = standard_planner(parse, cursorOptions, boundParams);
         return result;
     }
    
    
    

_10、CreatePortal_

    
    
     /*
      * CreatePortal
      *      Returns a new portal given a name.
      *
      * allowDup: if true, automatically drop any pre-existing portal of the
      * same name (if false, an error is raised).
      *
      * dupSilent: if true, don't even emit a WARNING.
      */
     Portal
     CreatePortal(const char *name, bool allowDup, bool dupSilent)
     {
         Portal      portal;
     
         AssertArg(PointerIsValid(name));
     
         portal = GetPortalByName(name);
         if (PortalIsValid(portal))
         {
             if (!allowDup)
                 ereport(ERROR,
                         (errcode(ERRCODE_DUPLICATE_CURSOR),
                          errmsg("cursor \"%s\" already exists", name)));
             if (!dupSilent)
                 ereport(WARNING,
                         (errcode(ERRCODE_DUPLICATE_CURSOR),
                          errmsg("closing existing cursor \"%s\"",
                                 name)));
             PortalDrop(portal, false);
         }
     
         /* make new portal structure */
         portal = (Portal) MemoryContextAllocZero(TopPortalContext, sizeof *portal);
     
         /* initialize portal context; typically it won't store much */
         portal->portalContext = AllocSetContextCreate(TopPortalContext,
                                                       "PortalContext",
                                                       ALLOCSET_SMALL_SIZES);
     
         /* create a resource owner for the portal */
         portal->resowner = ResourceOwnerCreate(CurTransactionResourceOwner,
                                                "Portal");
     
         /* initialize portal fields that don't start off zero */
         portal->status = PORTAL_NEW;
         portal->cleanup = PortalCleanup;
         portal->createSubid = GetCurrentSubTransactionId();
         portal->activeSubid = portal->createSubid;
         portal->strategy = PORTAL_MULTI_QUERY;
         portal->cursorOptions = CURSOR_OPT_NO_SCROLL;
         portal->atStart = true;
         portal->atEnd = true;       /* disallow fetches until query is set */
         portal->visible = true;
         portal->creation_time = GetCurrentStatementStartTimestamp();
     
         /* put portal in table (sets portal->name) */
         PortalHashTableInsert(portal, name);
     
         /* reuse portal->name copy */
         MemoryContextSetIdentifier(portal->portalContext, portal->name);
     
         return portal;
     }
    

_11、PortalDefineQuery_

    
    
     /*
      * PortalDefineQuery
      *      A simple subroutine to establish a portal's query.
      *
      * Notes: as of PG 8.4, caller MUST supply a sourceText string; it is not
      * allowed anymore to pass NULL.  (If you really don't have source text,
      * you can pass a constant string, perhaps "(query not available)".)
      *
      * commandTag shall be NULL if and only if the original query string
      * (before rewriting) was an empty string.  Also, the passed commandTag must
      * be a pointer to a constant string, since it is not copied.
      *
      * If cplan is provided, then it is a cached plan containing the stmts, and
      * the caller must have done GetCachedPlan(), causing a refcount increment.
      * The refcount will be released when the portal is destroyed.
      *
      * If cplan is NULL, then it is the caller's responsibility to ensure that
      * the passed plan trees have adequate lifetime.  Typically this is done by
      * copying them into the portal's context.
      *
      * The caller is also responsible for ensuring that the passed prepStmtName
      * (if not NULL) and sourceText have adequate lifetime.
      *
      * NB: this function mustn't do much beyond storing the passed values; in
      * particular don't do anything that risks elog(ERROR).  If that were to
      * happen here before storing the cplan reference, we'd leak the plancache
      * refcount that the caller is trying to hand off to us.
      */
     void
     PortalDefineQuery(Portal portal,
                       const char *prepStmtName,
                       const char *sourceText,
                       const char *commandTag,
                       List *stmts,
                       CachedPlan *cplan)
     {
         AssertArg(PortalIsValid(portal));
         AssertState(portal->status == PORTAL_NEW);
     
         AssertArg(sourceText != NULL);
         AssertArg(commandTag != NULL || stmts == NIL);
     
         portal->prepStmtName = prepStmtName;
         portal->sourceText = sourceText;
         portal->commandTag = commandTag;
         portal->stmts = stmts;
         portal->cplan = cplan;
         portal->status = PORTAL_DEFINED;
     }
     
    

_12、PortalStart_

    
    
     /*
      * PortalStart
      *      Prepare a portal for execution.
      *
      * Caller must already have created the portal, done PortalDefineQuery(),
      * and adjusted portal options if needed.
      *
      * If parameters are needed by the query, they must be passed in "params"
      * (caller is responsible for giving them appropriate lifetime).
      *
      * The caller can also provide an initial set of "eflags" to be passed to
      * ExecutorStart (but note these can be modified internally, and they are
      * currently only honored for PORTAL_ONE_SELECT portals).  Most callers
      * should simply pass zero.
      *
      * The caller can optionally pass a snapshot to be used; pass InvalidSnapshot
      * for the normal behavior of setting a new snapshot.  This parameter is
      * presently ignored for non-PORTAL_ONE_SELECT portals (it's only intended
      * to be used for cursors).
      *
      * On return, portal is ready to accept PortalRun() calls, and the result
      * tupdesc (if any) is known.
      */
     void
     PortalStart(Portal portal, ParamListInfo params,
                 int eflags, Snapshot snapshot)
     {
         Portal      saveActivePortal;
         ResourceOwner saveResourceOwner;
         MemoryContext savePortalContext;
         MemoryContext oldContext;
         QueryDesc  *queryDesc;
         int         myeflags;
     
         AssertArg(PortalIsValid(portal));
         AssertState(portal->status == PORTAL_DEFINED);
     
         /*
          * Set up global portal context pointers.
          */
         saveActivePortal = ActivePortal;
         saveResourceOwner = CurrentResourceOwner;
         savePortalContext = PortalContext;
         PG_TRY();
         {
             ActivePortal = portal;
             if (portal->resowner)
                 CurrentResourceOwner = portal->resowner;
             PortalContext = portal->portalContext;
     
             oldContext = MemoryContextSwitchTo(PortalContext);
     
             /* Must remember portal param list, if any */
             portal->portalParams = params;
     
             /*
              * Determine the portal execution strategy
              */
             portal->strategy = ChoosePortalStrategy(portal->stmts);
     
             /*
              * Fire her up according to the strategy
              */
             switch (portal->strategy)
             {
                 case PORTAL_ONE_SELECT:
     
                     /* Must set snapshot before starting executor. */
                     if (snapshot)
                         PushActiveSnapshot(snapshot);
                     else
                         PushActiveSnapshot(GetTransactionSnapshot());
     
                     /*
                      * Create QueryDesc in portal's context; for the moment, set
                      * the destination to DestNone.
                      */
                     queryDesc = CreateQueryDesc(linitial_node(PlannedStmt, portal->stmts),
                                                 portal->sourceText,
                                                 GetActiveSnapshot(),
                                                 InvalidSnapshot,
                                                 None_Receiver,
                                                 params,
                                                 portal->queryEnv,
                                                 0);
     
                     /*
                      * If it's a scrollable cursor, executor needs to support
                      * REWIND and backwards scan, as well as whatever the caller
                      * might've asked for.
                      */
                     if (portal->cursorOptions & CURSOR_OPT_SCROLL)
                         myeflags = eflags | EXEC_FLAG_REWIND | EXEC_FLAG_BACKWARD;
                     else
                         myeflags = eflags;
     
                     /*
                      * Call ExecutorStart to prepare the plan for execution
                      */
                     ExecutorStart(queryDesc, myeflags);
     
                     /*
                      * This tells PortalCleanup to shut down the executor
                      */
                     portal->queryDesc = queryDesc;
     
                     /*
                      * Remember tuple descriptor (computed by ExecutorStart)
                      */
                     portal->tupDesc = queryDesc->tupDesc;
     
                     /*
                      * Reset cursor position data to "start of query"
                      */
                     portal->atStart = true;
                     portal->atEnd = false;  /* allow fetches */
                     portal->portalPos = 0;
     
                     PopActiveSnapshot();
                     break;
     
                 case PORTAL_ONE_RETURNING:
                 case PORTAL_ONE_MOD_WITH:
     
                     /*
                      * We don't start the executor until we are told to run the
                      * portal.  We do need to set up the result tupdesc.
                      */
                     {
                         PlannedStmt *pstmt;
     
                         pstmt = PortalGetPrimaryStmt(portal);
                         portal->tupDesc =
                             ExecCleanTypeFromTL(pstmt->planTree->targetlist,
                                                 false);
                     }
     
                     /*
                      * Reset cursor position data to "start of query"
                      */
                     portal->atStart = true;
                     portal->atEnd = false;  /* allow fetches */
                     portal->portalPos = 0;
                     break;
     
                 case PORTAL_UTIL_SELECT:
     
                     /*
                      * We don't set snapshot here, because PortalRunUtility will
                      * take care of it if needed.
                      */
                     {
                         PlannedStmt *pstmt = PortalGetPrimaryStmt(portal);
     
                         Assert(pstmt->commandType == CMD_UTILITY);
                         portal->tupDesc = UtilityTupleDescriptor(pstmt->utilityStmt);
                     }
     
                     /*
                      * Reset cursor position data to "start of query"
                      */
                     portal->atStart = true;
                     portal->atEnd = false;  /* allow fetches */
                     portal->portalPos = 0;
                     break;
     
                 case PORTAL_MULTI_QUERY:
                     /* Need do nothing now */
                     portal->tupDesc = NULL;
                     break;
             }
         }
         PG_CATCH();
         {
             /* Uncaught error while executing portal: mark it dead */
             MarkPortalFailed(portal);
     
             /* Restore global vars and propagate error */
             ActivePortal = saveActivePortal;
             CurrentResourceOwner = saveResourceOwner;
             PortalContext = savePortalContext;
     
             PG_RE_THROW();
         }
         PG_END_TRY();
     
         MemoryContextSwitchTo(oldContext);
     
         ActivePortal = saveActivePortal;
         CurrentResourceOwner = saveResourceOwner;
         PortalContext = savePortalContext;
     
         portal->status = PORTAL_READY;
     }
    

_13、PortalSetResultFormat_

    
    
     /*
      * PortalSetResultFormat
      *      Select the format codes for a portal's output.
      *
      * This must be run after PortalStart for a portal that will be read by
      * a DestRemote or DestRemoteExecute destination.  It is not presently needed
      * for other destination types.
      *
      * formats[] is the client format request, as per Bind message conventions.
      */
     void
     PortalSetResultFormat(Portal portal, int nFormats, int16 *formats)
     {
         int         natts;
         int         i;
     
         /* Do nothing if portal won't return tuples */
         if (portal->tupDesc == NULL)
             return;
         natts = portal->tupDesc->natts;
         portal->formats = (int16 *)
             MemoryContextAlloc(portal->portalContext,
                                natts * sizeof(int16));
         if (nFormats > 1)
         {
             /* format specified for each column */
             if (nFormats != natts)
                 ereport(ERROR,
                         (errcode(ERRCODE_PROTOCOL_VIOLATION),
                          errmsg("bind message has %d result formats but query has %d columns",
                                 nFormats, natts)));
             memcpy(portal->formats, formats, natts * sizeof(int16));
         }
         else if (nFormats > 0)
         {
             /* single format specified, use for all columns */
             int16       format1 = formats[0];
     
             for (i = 0; i < natts; i++)
                 portal->formats[i] = format1;
         }
         else
         {
             /* use default format for all columns */
             for (i = 0; i < natts; i++)
                 portal->formats[i] = 0;
         }
     }
    

_14、CreateDestReceiver_

    
    
     /* ----------------      *      CreateDestReceiver - return appropriate receiver function set for dest
      * ----------------      */
     DestReceiver *
     CreateDestReceiver(CommandDest dest)
     {
         switch (dest)
         {
             case DestRemote:
             case DestRemoteExecute:
                 return printtup_create_DR(dest);
     
             case DestRemoteSimple:
                 return &printsimpleDR;
     
             case DestNone:
                 return &donothingDR;
     
             case DestDebug:
                 return &debugtupDR;
     
             case DestSPI:
                 return &spi_printtupDR;
     
             case DestTuplestore:
                 return CreateTuplestoreDestReceiver();
     
             case DestIntoRel:
                 return CreateIntoRelDestReceiver(NULL);
     
             case DestCopyOut:
                 return CreateCopyDestReceiver();
     
             case DestSQLFunction:
                 return CreateSQLFunctionDestReceiver();
     
             case DestTransientRel:
                 return CreateTransientRelDestReceiver(InvalidOid);
     
             case DestTupleQueue:
                 return CreateTupleQueueDestReceiver(NULL);
         }
     
         /* should never get here */
         return &donothingDR;
     }
    

_15、printtup_create_DR_

    
    
     /* ----------------      *      Initialize: create a DestReceiver for printtup
      * ----------------      */
     DestReceiver *
     printtup_create_DR(CommandDest dest)
     {
         DR_printtup *self = (DR_printtup *) palloc0(sizeof(DR_printtup));
     
         self->pub.receiveSlot = printtup;   /* might get changed later */
         self->pub.rStartup = printtup_startup;
         self->pub.rShutdown = printtup_shutdown;
         self->pub.rDestroy = printtup_destroy;
         self->pub.mydest = dest;
     
         /*
          * Send T message automatically if DestRemote, but not if
          * DestRemoteExecute
          */
         self->sendDescrip = (dest == DestRemote);
     
         self->attrinfo = NULL;
         self->nattrs = 0;
         self->myinfo = NULL;
         self->tmpcontext = NULL;
     
         return (DestReceiver *) self;
     }
     
    

_16、PortalDrop_

    
    
    /*
      * PortalDrop
      *      Destroy the portal.
      */
     void
     PortalDrop(Portal portal, bool isTopCommit)
     {
         AssertArg(PortalIsValid(portal));
     
         /*
          * Don't allow dropping a pinned portal, it's still needed by whoever
          * pinned it.
          */
         if (portal->portalPinned)
             ereport(ERROR,
                     (errcode(ERRCODE_INVALID_CURSOR_STATE),
                      errmsg("cannot drop pinned portal \"%s\"", portal->name)));
     
         /*
          * Not sure if the PORTAL_ACTIVE case can validly happen or not...
          */
         if (portal->status == PORTAL_ACTIVE)
             ereport(ERROR,
                     (errcode(ERRCODE_INVALID_CURSOR_STATE),
                      errmsg("cannot drop active portal \"%s\"", portal->name)));
     
         /*
          * Allow portalcmds.c to clean up the state it knows about, in particular
          * shutting down the executor if still active.  This step potentially runs
          * user-defined code so failure has to be expected.  It's the cleanup
          * hook's responsibility to not try to do that more than once, in the case
          * that failure occurs and then we come back to drop the portal again
          * during transaction abort.
          *
          * Note: in most paths of control, this will have been done already in
          * MarkPortalDone or MarkPortalFailed.  We're just making sure.
          */
         if (PointerIsValid(portal->cleanup))
         {
             portal->cleanup(portal);
             portal->cleanup = NULL;
         }
     
         /*
          * Remove portal from hash table.  Because we do this here, we will not
          * come back to try to remove the portal again if there's any error in the
          * subsequent steps.  Better to leak a little memory than to get into an
          * infinite error-recovery loop.
          */
         PortalHashTableDelete(portal);
     
         /* drop cached plan reference, if any */
         PortalReleaseCachedPlan(portal);
     
         /*
          * If portal has a snapshot protecting its data, release that.  This needs
          * a little care since the registration will be attached to the portal's
          * resowner; if the portal failed, we will already have released the
          * resowner (and the snapshot) during transaction abort.
          */
         if (portal->holdSnapshot)
         {
             if (portal->resowner)
                 UnregisterSnapshotFromOwner(portal->holdSnapshot,
                                             portal->resowner);
             portal->holdSnapshot = NULL;
         }
     
         /*
          * Release any resources still attached to the portal.  There are several
          * cases being covered here:
          *
          * Top transaction commit (indicated by isTopCommit): normally we should
          * do nothing here and let the regular end-of-transaction resource
          * releasing mechanism handle these resources too.  However, if we have a
          * FAILED portal (eg, a cursor that got an error), we'd better clean up
          * its resources to avoid resource-leakage warning messages.
          *
          * Sub transaction commit: never comes here at all, since we don't kill
          * any portals in AtSubCommit_Portals().
          *
          * Main or sub transaction abort: we will do nothing here because
          * portal->resowner was already set NULL; the resources were already
          * cleaned up in transaction abort.
          *
          * Ordinary portal drop: must release resources.  However, if the portal
          * is not FAILED then we do not release its locks.  The locks become the
          * responsibility of the transaction's ResourceOwner (since it is the
          * parent of the portal's owner) and will be released when the transaction
          * eventually ends.
          */
         if (portal->resowner &&
             (!isTopCommit || portal->status == PORTAL_FAILED))
         {
             bool        isCommit = (portal->status != PORTAL_FAILED);
     
             ResourceOwnerRelease(portal->resowner,
                                  RESOURCE_RELEASE_BEFORE_LOCKS,
                                  isCommit, false);
             ResourceOwnerRelease(portal->resowner,
                                  RESOURCE_RELEASE_LOCKS,
                                  isCommit, false);
             ResourceOwnerRelease(portal->resowner,
                                  RESOURCE_RELEASE_AFTER_LOCKS,
                                  isCommit, false);
             ResourceOwnerDelete(portal->resowner);
         }
         portal->resowner = NULL;
     
         /*
          * Delete tuplestore if present.  We should do this even under error
          * conditions; since the tuplestore would have been using cross-          * transaction storage, its temp files need to be explicitly deleted.
          */
         if (portal->holdStore)
         {
             MemoryContext oldcontext;
     
             oldcontext = MemoryContextSwitchTo(portal->holdContext);
             tuplestore_end(portal->holdStore);
             MemoryContextSwitchTo(oldcontext);
             portal->holdStore = NULL;
         }
     
         /* delete tuplestore storage, if any */
         if (portal->holdContext)
             MemoryContextDelete(portal->holdContext);
     
         /* release subsidiary storage */
         MemoryContextDelete(portal->portalContext);
     
         /* release portal struct (it's in TopPortalContext) */
         pfree(portal);
     }
    

_17、EndImplicitTransactionBlock_

    
    
     /*
      * EndImplicitTransactionBlock
      *      End an implicit transaction block, if we're in one.
      *
      * Like EndTransactionBlock, we just make any needed blockState change here.
      * The real work will be done in the upcoming CommitTransactionCommand().
      */
     void
     EndImplicitTransactionBlock(void)
     {
         TransactionState s = CurrentTransactionState;
     
         /*
          * If we are in IMPLICIT_INPROGRESS state, switch back to STARTED state,
          * allowing CommitTransactionCommand to commit whatever happened during
          * the implicit transaction block as though it were a single statement.
          *
          * For caller convenience, we consider all other transaction states as
          * legal here; otherwise the caller would need its own state check, which
          * seems rather pointless.
          */
         if (s->blockState == TBLOCK_IMPLICIT_INPROGRESS)
             s->blockState = TBLOCK_STARTED;
     }
     
    

_18、finish_xact_command_

    
    
     static void
     finish_xact_command(void)
     {
         /* cancel active statement timeout after each command */
         disable_statement_timeout();
     
         if (xact_started)
         {
             CommitTransactionCommand();
     
     #ifdef MEMORY_CONTEXT_CHECKING
             /* Check all memory contexts that weren't freed during commit */
             /* (those that were, were checked before being deleted) */
             MemoryContextCheck(TopMemoryContext);
     #endif
     
     #ifdef SHOW_MEMORY_STATS
             /* Print mem stats after each commit for leak tracking */
             MemoryContextStats(TopMemoryContext);
     #endif
     
             xact_started = false;
         }
     }
    

_19、CommandCounterIncrement_

    
    
    /*
      *  CommandCounterIncrement
      */
     void
     CommandCounterIncrement(void)
     {
         /*
          * If the current value of the command counter hasn't been "used" to mark
          * tuples, we need not increment it, since there's no need to distinguish
          * a read-only command from others.  This helps postpone command counter
          * overflow, and keeps no-op CommandCounterIncrement operations cheap.
          */
         if (currentCommandIdUsed)
         {
             /*
              * Workers synchronize transaction state at the beginning of each
              * parallel operation, so we can't account for new commands after that
              * point.
              */
             if (IsInParallelMode() || IsParallelWorker())
                 elog(ERROR, "cannot start commands during a parallel operation");
     
             currentCommandId += 1;
             if (currentCommandId == InvalidCommandId)
             {
                 currentCommandId -= 1;
                 ereport(ERROR,
                         (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
                          errmsg("cannot have more than 2^32-2 commands in a transaction")));
             }
             currentCommandIdUsed = false;
     
             /* Propagate new command ID into static snapshots */
             SnapshotSetCommandId(currentCommandId);
     
             /*
              * Make any catalog changes done by the just-completed command visible
              * in the local syscache.  We obviously don't need to do this after a
              * read-only command.  (But see hacks in inval.c to make real sure we
              * don't think a command that queued inval messages was read-only.)
              */
             AtCCI_LocalCache();
         }
     }
    

_20、EndCommand_

    
    
    /* ----------------      *      EndCommand - clean up the destination at end of command
      * ----------------      */
     void
     EndCommand(const char *commandTag, CommandDest dest)
     {
         switch (dest)
         {
             case DestRemote:
             case DestRemoteExecute:
             case DestRemoteSimple:
     
                 /*
                  * We assume the commandTag is plain ASCII and therefore requires
                  * no encoding conversion.
                  */
                 pq_putmessage('C', commandTag, strlen(commandTag) + 1);
                 break;
     
             case DestNone:
             case DestDebug:
             case DestSPI:
             case DestTuplestore:
             case DestIntoRel:
             case DestCopyOut:
             case DestSQLFunction:
             case DestTransientRel:
             case DestTupleQueue:
                 break;
         }
     }
    

### 三、跟踪分析

插入测试数据：

    
    
    testdb=# -- 获取pid
    testdb=# select pg_backend_pid();
     pg_backend_pid 
    ----------------               1893
    (1 row)
    testdb=# -- 插入1行
    testdb=# insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');
    (挂起)
    

启动gdb，跟踪调试：

    
    
    [root@localhost ~]# gdb -p 1893
    GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-100.el7
    Copyright (C) 2013 Free Software Foundation, Inc.
    ...
    (gdb) b exec_simple_query
    Breakpoint 1 at 0x84cad8: file postgres.c, line 893.
    (gdb) c
    Continuing.
    
    Breakpoint 1, exec_simple_query (query_string=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');") at postgres.c:893
    893     CommandDest dest = whereToSendOutput;
    #输入参数
    #query_string
    (gdb) p query_string
    $1 = 0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');"
    #单步调试
    938     oldcontext = MemoryContextSwitchTo(MessageContext);
    (gdb) p *MessageContext
    $2 = {type = T_AllocSetContext, isReset = false, allowInCritSection = false, methods = 0xb8c720 <AllocSetMethods>, parent = 0x1503ba0, firstchild = 0x0, prevchild = 0x157c3c0, nextchild = 0x15956d0, 
      name = 0xb4e87c "MessageContext", ident = 0x0, reset_cbs = 0x0}
    (gdb) n
    944     parsetree_list = pg_parse_query(query_string);
    (gdb) p oldcontext
    $3 = (MemoryContext) 0x15a8320
    (gdb) p *oldcontext
    $4 = {type = T_AllocSetContext, isReset = true, allowInCritSection = false, methods = 0xb8c720 <AllocSetMethods>, parent = 0x1503ba0, firstchild = 0x0, prevchild = 0x0, nextchild = 0x157c3c0, 
      name = 0xa1b4ff "TopTransactionContext", ident = 0x0, reset_cbs = 0x0}
    (gdb) step
    pg_parse_query (query_string=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');") at postgres.c:615
    615     if (log_parser_stats)
    (gdb) 
    618     raw_parsetree_list = raw_parser(query_string);
    #进入raw_parser
    (gdb) step
    raw_parser (str=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');") at parser.c:43
    43      yyscanner = scanner_init(str, &yyextra.core_yy_extra,
    (gdb) 
    ...
    61      return yyextra.parsetree;
    (gdb) p yyextra
    $8 = {core_yy_extra = {scanbuf = 0x1509820 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');", scanbuflen = 92, keywords = 0xbb8d40 <ScanKeywords>, 
        num_keywords = 440, backslash_quote = 2, escape_string_warning = true, standard_conforming_strings = true, literalbuf = 0x1509300 "exec_simple_query", literallen = 17, literalalloc = 1024, 
        xcdepth = 1087033144, dolqstart = 0x0, utf16_first_part = 16777215, warn_on_first_escape = true, saw_non_ascii = false}, have_lookahead = false, lookahead_token = 32765, lookahead_yylval = {
        ival = 10027008, str = 0x300990000 <Address 0x300990000 out of bounds>, keyword = 0x300990000 <Address 0x300990000 out of bounds>}, lookahead_yylloc = 2015867616, 
      lookahead_end = 0xa1b62b "StartTransaction", lookahead_hold_char = 16 '\020', parsetree = 0x1509d88}
    (gdb) p *(yyextra.parsetree)
    $10 = {type = T_List, length = 1, head = 0x1509d68, tail = 0x1509d68}
    #解析树中的内容
    (gdb) p *((RawStmt*)(yyextra.parsetree->head->data.ptr_value))
    $25 = {type = T_RawStmt, stmt = 0x1509ce8, stmt_location = 0, stmt_len = 91}
    (gdb) p *(((RawStmt*)(yyextra.parsetree->head->data.ptr_value))->stmt)
    $27 = {type = T_InsertStmt}
    #跳出子函数，重新进入主函数
    (gdb) 
    exec_simple_query (query_string=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');") at postgres.c:947
    947     if (check_log_statement(parsetree_list))
    ...
    #解析树只有一个元素
    (gdb) n
    974     foreach(parsetree_item, parsetree_list)
    (gdb) p list_length(parsetree_list)
    $30 = 1
    (gdb) n
    976         RawStmt    *parsetree = lfirst_node(RawStmt, parsetree_item);
    (gdb) 
    977         bool        snapshot_set = false;
    (gdb) p *parsetree
    $31 = {type = T_RawStmt, stmt = 0x1509ce8, stmt_location = 0, stmt_len = 91}
    (gdb) p *(parsetree->stmt)
    $32 = {type = T_InsertStmt}
    #commandTag
    (gdb) n
    992         commandTag = CreateCommandTag(parsetree->stmt);
    (gdb) 
    994         set_ps_display(commandTag, false);
    (gdb) p commandTag
    $33 = 0xb50908 "INSERT"
    #进入分析&查询重写
    1047            querytree_list = pg_analyze_and_rewrite(parsetree, query_string,
    (gdb) step
    pg_analyze_and_rewrite (parsetree=0x1509d38, query_string=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');", paramTypes=0x0, numParams=0, 
        queryEnv=0x0) at postgres.c:663
    663     if (log_parser_stats)
    ...
    #分析后的Query数据结构
    (gdb) p *query
    $34 = {type = T_Query, commandType = CMD_INSERT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = true, utilityStmt = 0x0, resultRelation = 1, hasAggs = false, hasWindowFuncs = false, 
      hasTargetSRFs = false, hasSubLinks = false, hasDistinctOn = false, hasRecursive = false, hasModifyingCTE = false, hasForUpdate = false, hasRowSecurity = false, cteList = 0x0, rtable = 0x150a788, 
      jointree = 0x152cf40, targetList = 0x152cda8, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, 
      distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 91}
    ...
    #回到主函数
    (gdb) 
    exec_simple_query (query_string=0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');") at postgres.c:1050
    1050            plantree_list = pg_plan_queries(querytree_list,
    (gdb) 
    1054            if (snapshot_set)
    (gdb) 
    1055                PopActiveSnapshot();
    (gdb) 
    1058            CHECK_FOR_INTERRUPTS();
    (gdb) 
    1064            portal = CreatePortal("", true, true);
    (gdb) p *plantree_list
    $36 = {type = T_List, length = 1, head = 0x15c03e8, tail = 0x15c03e8}
    (gdb) p (PlannedStmt*)(plantree_list->head->data.ptr_value)
    $37 = (PlannedStmt *) 0x150a4a8
    (gdb) p *((PlannedStmt*)(plantree_list->head->data.ptr_value))
    $38 = {type = T_PlannedStmt, commandType = CMD_INSERT, queryId = 0, hasReturning = false, hasModifyingCTE = false, canSetTag = true, transientPlan = false, dependsOnRole = false, 
      parallelModeNeeded = false, jitFlags = 0, planTree = 0x150a028, rtable = 0x15c0318, resultRelations = 0x15c03b8, nonleafResultRelations = 0x0, rootResultRelations = 0x0, subplans = 0x0, 
      rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x15c0368, invalItems = 0x0, paramExecTypes = 0x152e720, utilityStmt = 0x0, stmt_location = 0, stmt_len = 91}
    #Portal
    ...
    (gdb) p *portal
    $40 = {name = 0x1571e98 "", prepStmtName = 0x0, portalContext = 0x152c3d0, resowner = 0x1539d10, cleanup = 0x62f15c <PortalCleanup>, createSubid = 1, activeSubid = 1, sourceText = 0x0, 
      commandTag = 0x0, stmts = 0x0, cplan = 0x0, portalParams = 0x0, queryEnv = 0x0, strategy = PORTAL_MULTI_QUERY, cursorOptions = 4, run_once = false, status = PORTAL_NEW, portalPinned = false, 
      autoHeld = false, queryDesc = 0x0, tupDesc = 0x0, formats = 0x0, holdStore = 0x0, holdContext = 0x0, holdSnapshot = 0x0, atStart = true, atEnd = true, portalPos = 0, creation_time = 587101481469205, 
      visible = true}
    (gdb) n
    1073            PortalDefineQuery(portal,
    (gdb) 
    1083            PortalStart(portal, NULL, 0, InvalidSnapshot);
    (gdb) 
    1091            format = 0;             /* TEXT is default */
    (gdb) 
    1092            if (IsA(parsetree->stmt, FetchStmt))
    (gdb)  p *portal
    $41 = {name = 0x1571e98 "", prepStmtName = 0x0, portalContext = 0x152c3d0, resowner = 0x1539d10, cleanup = 0x62f15c <PortalCleanup>, createSubid = 1, activeSubid = 1, 
      sourceText = 0x1508ef0 "insert into t_insert values(22,'exec_simple_query','exec_simple_query','exec_simple_query');", commandTag = 0xb50908 "INSERT", stmts = 0x15c0408, cplan = 0x0, 
      portalParams = 0x0, queryEnv = 0x0, strategy = PORTAL_MULTI_QUERY, cursorOptions = 4, run_once = false, status = PORTAL_READY, portalPinned = false, autoHeld = false, queryDesc = 0x0, tupDesc = 0x0, 
      formats = 0x0, holdStore = 0x0, holdContext = 0x0, holdSnapshot = 0x0, atStart = true, atEnd = true, portalPos = 0, creation_time = 587101481469205, visible = false}
    #Receiver
    1110            receiver = CreateDestReceiver(dest);
    (gdb) 
    1111            if (dest == DestRemote)
    (gdb) p *receiver
    $42 = {receiveSlot = 0x4857ad <printtup>, rStartup = 0x485196 <printtup_startup>, rShutdown = 0x485bad <printtup_shutdown>, rDestroy = 0x485c21 <printtup_destroy>, mydest = DestRemote}
    (gdb) 
    #执行
    ...
    1122            (void) PortalRun(portal,
    (gdb)
    ...
    #DONE!
    (gdb) 
    PostgresMain (argc=1, argv=0x1532aa8, dbname=0x1532990 "testdb", username=0x1532978 "xdb") at postgres.c:4155
    4155                        send_ready_for_query = true;
    

### 四、小结

1、执行/数据流程：SQL语句->解析树RawStmt>查询结构体Query->规划执行PlannedStmt->执行处理ExecProcNode  
2、重要的数据结构：本节重要的数据结构是RawStmt、Portal和Query  
3、关键的方法：创建Portal“对象”CreatePortal、语句解析pg_parse_query、语句分析&重写pg_analyze_and_rewrite、规划执行pg_plan_queries、规划执行（每个语句）pg_plan_query

